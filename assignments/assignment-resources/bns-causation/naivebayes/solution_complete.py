#!/usr/bin/env python
# coding: utf-8

import csv
import itertools


# In[5]:


from bnetbase import Variable, Factor, BN

def get_values(input_data, factor):
    vals = {}
    vals['Work'] = 0
    vals['Education'] = 1
    vals['MaritalStatus'] = 2
    vals['Occupation'] = 3
    vals['Relationship'] = 4
    vals['Race'] = 5
    vals['Gender'] = 6
    vals['Country'] = 7
    vals['Salary'] = 8
    vals['Age'] = 9
    vals['HoursPerWeek'] = 10

    #should likely rewrite this using pandas/numpy
    #df = pd.DataFrame(input_data)
    toReturn = []
    scope = factor.get_scope()
    var0 = scope[0]
    hold = vals[var0.name]
    dom0 = var0.domain()
    if len(scope) == 1:
        retDict = {}
        normalization = 0
        for d in dom0:  
            for row in input_data:
                if (d in row): 
                    normalization += 1
                    retDict[d] = retDict.get(d,0) + 1              
        for d in dom0: 
            if (normalization > 0):
                retDict[d] = retDict.get(d, 0)/normalization
        for key in retDict.keys(): 
            s = key + "," + str(round(retDict[key],2))
            toReturn.append(s.split(","))
            toReturn[-1][-1] = float(toReturn[-1][-1])
    else:
        conditioning_set = []
        names = []
        for s in scope[1:]:
            conditioning_set.append(list(s.domain()))
            names.append(vals[s.name])

        # all possible combinations of value assignments
        combinations = list(itertools.product(*conditioning_set))
        ct = len(combinations)
        for c in combinations: 
            retDict = {}
            normalization = 0
            for d in dom0:  
                for row in input_data:
                    match =  all(elem in row for elem in c) and d in row
                    if (match): 
                        normalization += 1
                        retDict[(d,*c)] = retDict.get((d,*c),0) + 1
            for d in dom0: 
                if (normalization > 0):
                    retDict[(d,*c)] = retDict.get((d,*c), 0)/normalization
            total = 0
            for key in retDict.keys(): 
                s = ",".join(list(key)) + "," + str(round(retDict[key],2))
                toReturn.append(s.split(","))
                toReturn[-1][-1] = float(toReturn[-1][-1])
            ct -= 1
    return toReturn


def multiply_factors(Factors):
    '''Factors is a list of factor objects.
    Return a new factor that is the product of the factors in Factors'''
    scope = []
    for f in Factors:
        for v in f.get_scope():
            if not v in scope:
                scope.append(v)
    F = Factor("Product{}".format(Factors), scope)
    def recursive_multiply(Vars):
        if len(Vars) == 1:
            for val in Vars[0].domain():
                Vars[0].set_assignment(val)
                prod = 1
                for f in Factors:
                    prod = prod * f.get_value_at_current_assignments()
                F.add_value_at_current_assignment(prod)
        else:
            for val in Vars[0].domain():
                Vars[0].set_assignment(val)
                recursive_multiply(Vars[1:])
    recursive_multiply(scope)
    return F

def restrict_factor(f, var, value):
    '''f is a factor, var is a Variable, and value is a value from var.domain.
    Return a new factor that is the restriction of f by this var = value.
    Don't change f! If f has only one variable its restriction yields a
    constant factor.'''
    scope = f.get_scope()
    scope.remove(var)
    F = Factor("Restrict {}|{}={}".format(f.name, var.name, value),scope)    
    var.set_assignment(value) 
    def recursive_restrict_factor(Vars):
        if len(Vars) == 0:
            F.add_value_at_current_assignment(f.get_value_at_current_assignments())
        elif Vars[0] != var:
            for val in Vars[0].domain():
                Vars[0].set_assignment(val)
                recursive_restrict_factor(Vars[1:])
        else:
            recursive_restrict_factor(Vars[1:])
            
    recursive_restrict_factor(f.get_scope())
    return F

def sum_out_variable(f, var):
    '''f is a factor, var is a Variable.
    Return a new factor that is the result of summing var out of f, by summing
    the function generated by the product over all values of var.'''
    scope = f.get_scope()
    scope.remove(var)
    F = Factor("Eliminate-{}-{}".format(var.name,f), scope)
    def recursive_eliminate_variable(Vars):
        if len(Vars) == 0:
            summ = 0
            for val in var.domain():
                var.set_assignment(val)
                prod = f.get_value_at_current_assignments()
                summ = summ + prod
            F.add_value_at_current_assignment(summ)
        else:
            for val in Vars[0].domain():
                Vars[0].set_assignment(val)
                recursive_eliminate_variable(Vars[1:])
    recursive_eliminate_variable(scope)
    return F

def normalize(nums):
    '''num is a list of numbers. Return a new list of numbers where the new
    numbers sum to 1, i.e., normalize the input numbers.'''
    s = sum(nums)
    if s == 0:
        newnums = [0]*len(nums)
    else:
        newnums = []
        for n in nums:
            newnums.append(n/s)
    return newnums


def min_fill_ordering(Factors, QueryVar):
    '''Factors is a list of factor objects, QueryVar is a query variable.
    Compute an elimination order given list of factors using the min fill heuristic. 
    Variables in the list will be derived from the scopes of the factors in Factors. 
    Order the list such that the first variable in the list generates the smallest
    factor upon elimination. The QueryVar must NOT part of the returned ordering list.'''
    scopes = []
    for f in Factors:
        scopes.append(list(f.get_scope()))
    Vars = []
    for s in scopes:
        for v in s:
            if not v in Vars and v != QueryVar:
                Vars.append(v)
    
    ordering = []
    while Vars:
        (var,new_scope) = min_fill_var(scopes,Vars)
        ordering.append(var)
        if var in Vars:
            Vars.remove(var)
        scopes = remove_var(var, new_scope, scopes)
    return ordering

def min_fill_var(scopes, Vars):
    '''Given a set of scopes (lists of lists of variables) compute and
    return the variable with minimum fill in. That the variable that
    generates a factor of smallest scope when eliminated from the set
    of scopes. Also return the new scope generated from eliminating
    that variable.'''
    minv = Vars[0]
    (minfill,min_new_scope) = compute_fill(scopes,Vars[0])
    for v in Vars[1:]:
        (fill, new_scope) = compute_fill(scopes, v)
        if fill < minfill:
            minv = v
            minfill = fill
            min_new_scope = new_scope
    return (minv, min_new_scope)

def compute_fill(scopes, var):
    '''Return the fill in scope generated by eliminating var from
    scopes along with the size of this new scope'''
    union = []
    for s in scopes:
        if var in s:
            for v in s:
                if not v in union:
                    union.append(v)
    if var in union: union.remove(var)
    return (len(union), union)

def remove_var(var, new_scope, scopes):
    '''Return the new set of scopes that arise from eliminating var
    from scopes'''
    new_scopes = []
    for s in scopes:
        if not var in s:
            new_scopes.append(s)
    new_scopes.append(new_scope)
    return new_scopes


def VE(Net, QueryVar, EvidenceVars):
    
    """
    Input: Net---a BN object (a Bayes Net)
           QueryVar---a Variable object (the variable whose distribution
                      we want to compute)
           EvidenceVars---a LIST of Variable objects. Each of these
                          variables has had its evidence set to a particular
                          value from its domain using set_evidence.
     VE returns a distribution over the values of QueryVar, i.e., a list
     of numbers one for every value in QueryVar's domain. These numbers
     sum to one, and the i'th number is the probability that QueryVar is
     equal to its i'th value given the setting of the evidence
     variables. For example if QueryVar = A with Dom[A] = ['a', 'b',
     'c'], EvidenceVars = [B, C], and we have previously called
     B.set_evidence(1) and C.set_evidence('c'), then VE would return a
     list of three numbers. E.g. [0.5, 0.24, 0.26]. These numbers would
     mean that Pr(A='a'|B=1, C='c') = 0.5 Pr(A='a'|B=1, C='c') = 0.24
     Pr(A='a'|B=1, C='c') = 0.26
     """
       
    Factors = Net.factors() #note we get a copy so it is safe to modify this copy

    ##1. restrict by evidence
    for i in range(len(Factors)):
        f = Factors[i]
        newf = f
        for s in newf.get_scope():
            if s in EvidenceVars:
                newf = restrict_factor(newf, s, s.get_evidence())
                #note that a factor might get restricted multiple times.
        Factors[i] = newf #replace the old factor

    ##compute min-fill ordering
    order = min_fill_ordering(Factors, QueryVar)
    for v in order: 
        ##find factors over v
        v_factors = []
        for f in Factors:
            if v in f.get_scope():
                v_factors.append(f)
        #remove from list of factors
        for f in v_factors:
            Factors.remove(f)
        #eliminate v
        if len(v_factors) > 1:
            newf = multiply_factors(v_factors)
        else:
            newf = v_factors[0]
        newf = sum_out_variable(newf, v)
        Factors.append(newf)
    final_factor = multiply_factors(Factors)
    distribution = final_factor.values
    if sum(distribution) == 0:
        dist = [float('inf')] * len(distribution)
    else:
        dist = normalize(distribution)
    return(dist)

def NaiveBayesModel():
    '''
   NaiveBayesModel returns a BN that is a Naive Bayes model that 
   represents the joint distribution of value assignments to 
   variables in the Adult Dataset from UCI.  Remember a Naive Bayes model
   assumes P(X1, X2,.... XN, Class) can be represented as 
   P(X1|Class)*P(X2|Class)* .... *P(XN|Class)*P(Class).
   When you generated your Bayes Net, assume that the values 
   in the SALARY column of the dataset are the CLASS that we want to predict.
   @return a BN that is a Naive Bayes model and which represents the Adult Dataset. 
    '''
    ### READ IN THE DATA
    input_data = []
    with open('adult-dataset.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None) #skip header row
        for row in reader:
            input_data.append(row)

    ### DOMAIN INFORMATION REFLECTS ORDER OF COLUMNS IN THE DATA SET
    variable_domains = {
    "MaritalStatus": ['Not-Married', 'Married', 'Separated', 'Widowed'],
    "Relationship": ['Wife', 'Own-child', 'Husband', 'Not-in-family', 'Other-relative', 'Unmarried'],
    "Race": ['White', 'Black', 'Asian-Pac-Islander', 'Amer-Indian-Eskimo', 'Other'],
    "Gender": ['Male', 'Female'],
    "Occupation": ['Admin', 'Military', 'Manual Labour', 'Office Labour', 'Service', 'Professional'],
    "Country": ['North-America', 'South-America', 'Europe', 'Asia', 'Middle-East', 'Carribean'],
    "Education": ['<Gr12', 'HS-Graduate', 'Associate', 'Professional', 'Bachelors', 'Masters', 'Doctorate'],
    "Work": ['Not Working', 'Government', 'Private', 'Self-emp'],
    "Salary": ['<50K', '>=50K']
    }

    ### YOUR CODE GOES HERE ###
    variables = []
    factors = []
    variables.append(Variable("Salary", variable_domains["Salary"]))
    factors.append(Factor("P({})".format("Salary"), [variables[0]]))
    values = get_values(input_data, factors[0])
    factors[0].add_values(values)
    for key in variable_domains.keys():
        variables.append(Variable(key, variable_domains[key]))
        factors.append(Factor("P({}|{})".format(key,"Salary"), [variables[-1], variables[0]]))        
        values = get_values(input_data, factors[-1])
        factors[-1].add_values(values)
    model = BN('Adult Dataset', variables, factors) 
    return model

def Explore():
    fc, fc1, fc2, fc3 = 0, 0, 0, 0
    mc, mc1, mc2, mc3 = 0, 0, 0, 0
    adults = NaiveBayesModel()
    test_data = []
    with open('test-data.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None) #skip header row
        for row in reader:
            test_data.append(row)
    results = {'Male':[0,0,0,0],'Female':[0,0,0,0]}
    for row in test_data:
        salary = row[-1]
        work = row[0]
        education = row[1]   
        occupation = row[3]        
        relationship = row[4]   
        gender = row[6]
        re = adults.get_variable("Relationship")  
        re.set_evidence(relationship)
        ge = adults.get_variable("Gender")  
        ge.set_evidence(gender)
        oc = adults.get_variable("Occupation")  
        oc.set_evidence(occupation)     
        ed = adults.get_variable("Education")  
        ed.set_evidence(education)   
        wo = adults.get_variable("Work")  
        wo.set_evidence(work)     
        sa = adults.get_variable("Salary")  
        probs1 = VE(adults, sa, [ed, oc, wo, re])
        probs2 = VE(adults, sa, [ed, oc, wo, re, ge])
        if (gender == 'Female'):
            fc += 1 #count of all women
            if (probs2[1] < probs1[1]):
                fc1 += 1 #count of all women where gender biases prediction
            if probs1[1] > 0.5:
                fc2 += 1 #count of all women where prediction is > 50K
                if salary == ">=50K":
                    fc3 += 1 #count of all women where prediction is accurate
        if (gender == 'Male'):
            mc += 1 #count of all men
            if (probs2[1] < probs1[1]):
                mc1 += 1 #count of all women where gender biases prediction         
            if probs1[1] > 0.5:
                mc2 += 1 #count of all men where prediction is > 50K
                if salary == ">=50K":
                    mc3 += 1 #count of all men where prediction is accurate
        # if probs[1] > probs[0]: guess = 1
        # else: guess = 0

        # if (guess == 1 and int(salary) == 1): #TP       
        #     results[gender][0] = results[gender][0] + 1  
        # elif (guess == 1 and int(salary) == 0): #FP
        #     results[gender][1] = results[gender][1] + 1               
        # elif (guess == 0 and int(salary) == 0): #TN
        #     results[gender][2] = results[gender][2] + 1   
        # elif (guess == 0 and int(salary) == 1): #FN 
        #     results[gender][3] = results[gender][3] + 1
      
    # print("female: {} {} {} {}".format(fc, fc1, fc2, fc3))
    # print("male: {} {} {} {}".format(mc, mc1, mc2, mc3))
    
    #print("Q1: {}%".format((fc1/fc)*100))
    #print("Q2: {}%".format((mc1/mc)*100))
    #print("Q3: {}%".format((fc3/fc2)*100))
    #print("Q4: {}%".format((mc3/mc2)*100))
    #print("Q5: {}%".format((fc2/fc)*100))
    #print("Q6: {}%".format((mc2/mc)*100))   

    # print(results)
    # print("PPV female: {}".format(results['Female'][0]/(results['Female'][0] + results['Female'][3])))
    # print("PPV male: {}".format(results['Male'][0]/(results['Male'][0] + results['Male'][3]))) 
    # print("accuracy female: {}".format((results['Female'][0] + results['Female'][2])/(results['Female'][0] + results['Female'][1] + results['Female'][2] + results['Female'][3])))
    # print("accuracy male: {}".format((results['Male'][0] + results['Male'][2])/(results['Male'][0] + results['Male'][1] + results['Male'][2] + results['Male'][3])))
    # print("accuracy overall: {}".format((results['Male'][0] + results['Male'][2]+results['Female'][0] + results['Female'][2])/(results['Male'][0] + results['Male'][1] + results['Male'][2] + results['Male'][3]+results['Female'][0] + results['Female'][1] + results['Female'][2] + results['Female'][3])))
    Q1=((fc1/fc)*100)
    Q2=((mc1/mc)*100)
    Q3=((fc3/fc2)*100)
    Q4=((mc3/mc2)*100)
    Q5=((fc2/fc)*100)
    Q6=((mc2/mc)*100)
    return Q1,Q2,Q3,Q4,Q5,Q6


# In[26]:


if __name__ == '__main__':
    print(Explore())


# In[ ]:




