#!/usr/bin/env python
import os  # for time functions
import traceback
import sys
import re
import importlib
import subprocess
import itertools

from bnetbase import Variable, Factor, BN, adultDatasetBN, adultDatasetBN2
import csv

#from cspbase import BT, Variable, Constraint, CSP, ord_mrv_TA, KropkiBoard

from utilities import sortInnerMostLists, TO_exc, setTO, setMEM, resetMEM

#from boards import small_models, small_solutions, big_models, big_solutions 

#from kropki_csp_TA import kropki_csp_model_1_TA

os.environ['SDL_VIDEODRIVER'] = 'dummy'


SOLUTION = 'solution.py'
DEFAULT_TIMEOUT = 2



###Orderings
def min_fill_ordering_TA(Factors, QueryVar):
    '''Compute a min fill ordering given a list of factors. Return a list
    of variables from the scopes of the factors in Factors. The QueryVar is 
    NOT part of the returned ordering'''
    scopes = []
    for f in Factors:
        scopes.append(list(f.get_scope()))
    Vars = []
    for s in scopes:
        for v in s:
            if not v in Vars and v != QueryVar:
                Vars.append(v)
    
    ordering = []
    while Vars:
        (var,new_scope) = min_fill_var(scopes,Vars)
        ordering.append(var)
        if var in Vars:
            Vars.remove(var)
        scopes = remove_var(var, new_scope, scopes)
    return ordering

def min_fill_var(scopes, Vars):
    '''Given a set of scopes (lists of lists of variables) compute and
    return the variable with minimum fill in. That the variable that
    generates a factor of smallest scope when eliminated from the set
    of scopes. Also return the new scope generated from eliminating
    that variable.'''
    minv = Vars[0]
    (minfill,min_new_scope) = compute_fill(scopes,Vars[0])
    for v in Vars[1:]:
        (fill, new_scope) = compute_fill(scopes, v)
        if fill < minfill:
            minv = v
            minfill = fill
            min_new_scope = new_scope
    return (minv, min_new_scope)

def compute_fill(scopes, var):
    '''Return the fill in scope generated by eliminating var from
    scopes along with the size of this new scope'''
    union = []
    for s in scopes:
        if var in s:
            for v in s:
                if not v in union:
                    union.append(v)
    if var in union: union.remove(var)
    return (len(union), union)

def remove_var(var, new_scope, scopes):
    '''Return the new set of scopes that arise from eliminating var
    from scopes'''
    new_scopes = []
    for s in scopes:
        if not var in s:
            new_scopes.append(s)
    new_scopes.append(new_scope)
    return new_scopes
            


#NB TESTS (worth 20)
def nb_test_1(stu_solution):
    #stu_solution = student_modules[SOLUTION] 
    details = set()
    score = 0

    nb = stu_solution.NaiveBayesModel()
    prior_count = 0
    for f in nb.Factors:
        s = f.scope
        if (len(s) == 1): prior_count += 1
        if (len(s) > 2): 
            score -= 1
            details.add("Model is NOT a Naive Bayes Model.")  

    if prior_count > 1:
        score -= 1
        details.add("Model is NOT a Naive Bayes Model.")  

    if score == 0:
        details.add("Model is structured like a Naive Bayes Model.")  
        score = 10
    else:
        score = 0

    details.add("nb_test_1:  {}".format(score))
    #details = "\n".join(details)    
    return score, details

def nb_test_2(stu_solution):
    #stu_solution = student_modules[SOLUTION] 
    details = set()
    score = 0
    scopes = {}

    model = stu_solution.NaiveBayesModel()
    for f in model.Factors:
        if len(f.get_scope()) == 1:
            if (f.sum_table() == 1):
                score += 2
            else:
               details.add("Values in table with scope {} don't reflect probabilities.".format(f.get_scope())) 
        
        if len(f.get_scope()) == 2: 
            if str(f.get_scope()) not in scopes.keys():  
                scopes[str(f.get_scope())] = f.sum_table()
            else:   
                scopes[str(f.get_scope())] = f.sum_table() + scopes[str(f.get_scope())]

    for key in scopes.keys():
        if (abs(scopes[key] - 2) < 0.02):
            score += 1
        else:
            details.add("Values in table with scope {} don't collectively sum to 2.".format(key)) 

    details.add("nb_test_2:  {}".format(score))
    #details = "\n".join(details)    
    return score, details

#MINFILL TEST (worth 7)
#@max_grade(2)
def minfill_test_1(stu_solution):
    #stu_solution = student_modules[SOLUTION] 
    details = set()
    score = 0

    myBN = adultDatasetBN()

    # ordering = min_fill_ordering_TA(myBN.factors(),myBN.variables()[0])
    # print(ordering)
    ordering2 = stu_solution.min_fill_ordering(myBN.factors(),myBN.variables()[0])

    if (ordering2[0].name == 'Work' or ordering2[0].name == 'Country'):
        score = 3
    else:
       details.add("Min fill choice of variable should be Work or Country") 
    
    #print(ordering2)
    #details.add(model)

    details.add("minfill_test_1:  {}".format(score))
    #details = "\n".join(details)    
    return score, details

#@max_grade(2)
def minfill_test_2(stu_solution):
    #stu_solution = student_modules[SOLUTION] 
    details = set()
    score = 0

    myBN = adultDatasetBN2()

    # ordering = min_fill_ordering_TA(myBN.factors(),myBN.variables()[5])
    # print(ordering)
    ordering2 = stu_solution.min_fill_ordering(myBN.factors(),myBN.variables()[5])

    if (ordering2[0].name == 'Race'):
        score = 4
    else:
       details.add("Min fill choice of variable should be Work or Country") 
    
    #print(ordering2)
    #details.add(model)

    details.add("minfill_test_2: {}".format(score))
    #details = "\n".join(details)    
    return score, details


#PROBLEM TEST (worth 7)
#@max_grade(2)
def problem_test_1(stu_solution):
    #stu_solution = student_modules[SOLUTION] 
    details = set()
    score = 0
    myBN = stu_solution.NaiveBayesModel()
    sol = [100, 0.0, 4.6, 16.9, 8.1, 25.4]
    sol2 = [100, 0.0, 57.21, 66.23, 8.1, 25.4]

# What percentage of the women in the test data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
# What percentage of the men in the test data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
# What percentage of the women in the test data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
# What percentage of the men in the test data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
# What percentage of the women in the test data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
# What percentage of the men in the test data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
    wiggle = 3
    if('Explore' in dir(stu_solution)):

        ans1 = stu_solution.Explore(myBN,1)
        if (abs(ans1 - sol[0]) < wiggle):
            score += 2
        ans2 = stu_solution.Explore(myBN,2)
        if (abs(ans2 - sol[1]) < wiggle):
            score += 2    
        if (ans1 > ans2):
            score += 2
        ans3 = stu_solution.Explore(myBN,3)
        if (abs(ans3 - sol[2]) < wiggle):
            score += 2   
        ans4 = stu_solution.Explore(myBN,4)
        if (abs(ans4 - sol[3]) < wiggle):
            score += 2    
        if (ans3 < ans4):
            score += 2            
        ans5 = stu_solution.Explore(myBN,5)
        if (abs(ans5 - sol[4]) < wiggle):
            score += 3   
        ans6 = stu_solution.Explore(myBN,6)
        if (abs(ans6 - sol[5]) < wiggle):
            score += 3  
        if (ans5 < ans6):
            score += 2                

        #details.add("{} {} {} {} {} {}".format(ans1, ans2, ans3, ans4, ans5, ans6))
        details.add("problem_test_1:  {}".format(score))
     
    elif('explore' in dir(stu_solution)):

        ans1 = stu_solution.explore(myBN,1)
        if (abs(ans1 - sol[0]) < wiggle):
            score += 2
        ans2 = stu_solution.explore(myBN,2)
        if (abs(ans2 - sol[1]) < wiggle):
            score += 2    
        if (ans1 > ans2):
            score += 2
        ans3 = stu_solution.explore(myBN,3)
        if (abs(ans3 - sol[2]) < wiggle):
            score += 2   
        ans4 = stu_solution.explore(myBN,4)
        if (abs(ans4 - sol[3]) < wiggle):
            score += 2    
        if (ans3 < ans4):
            score += 2            
        ans5 = stu_solution.explore(myBN,5)
        if (abs(ans5 - sol[4]) < wiggle):
            score += 3   
        ans6 = stu_solution.explore(myBN,6)
        if (abs(ans6 - sol[5]) < wiggle):
            score += 3  
        if (ans5 < ans6):
            score += 2      

        details.add("problem_test_1:  {}".format(score))
    

    #details = "\n".join(details)    
    return score, details


#PROBLEM TEST (worth 7)
#@max_grade(2)
def problem_test_2(stu_solution):
    #stu_solution = student_modules[SOLUTION] 
    details = set()
    score = 0
    myBN = stu_solution.NaiveBayesModel()
    sol = [100, 0.0, 4.6, 16.9, 8.1, 25.4]
    sol = [100, 0.0, 57.21, 66.23, 8.1, 25.4]

# What percentage of the women in the test data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
# What percentage of the men in the test data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
# What percentage of the women in the test data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
# What percentage of the men in the test data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
# What percentage of the women in the test data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
# What percentage of the men in the test data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
    wiggle = 3
    if('Explore' in dir(stu_solution)):

        ans1 = stu_solution.Explore(myBN,1)
        if (abs(ans1 - sol[0]) < wiggle):
            score += 2
        ans2 = stu_solution.Explore(myBN,2)
        if (abs(ans2 - sol[1]) < wiggle):
            score += 2    
        if (ans1 > ans2):
            score += 2
        ans3 = stu_solution.Explore(myBN,3)
        if (abs(ans3 - sol[2]) < wiggle):
            score += 2   
        ans4 = stu_solution.Explore(myBN,4)
        if (abs(ans4 - sol[3]) < wiggle):
            score += 2    
        if (ans3 < ans4):
            score += 2            
        ans5 = stu_solution.Explore(myBN,5)
        if (abs(ans5 - sol[4]) < wiggle):
            score += 3   
        ans6 = stu_solution.Explore(myBN,6)
        if (abs(ans6 - sol[5]) < wiggle):
            score += 3  
        if (ans5 < ans6):
            score += 2                

        #details.add("{} {} {} {} {} {}".format(ans1, ans2, ans3, ans4, ans5, ans6))
        details.add("problem_test_2:  {}".format(score))
     
    elif('explore' in dir(stu_solution)):

        ans1 = stu_solution.explore(myBN,1)
        if (abs(ans1 - sol[0]) < wiggle):
            score += 2
        ans2 = stu_solution.explore(myBN,2)
        if (abs(ans2 - sol[1]) < wiggle):
            score += 2    
        if (ans1 > ans2):
            score += 2
        ans3 = stu_solution.explore(myBN,3)
        if (abs(ans3 - sol[2]) < wiggle):
            score += 2   
        ans4 = stu_solution.explore(myBN,4)
        if (abs(ans4 - sol[3]) < wiggle):
            score += 2    
        if (ans3 < ans4):
            score += 2            
        ans5 = stu_solution.explore(myBN,5)
        if (abs(ans5 - sol[4]) < wiggle):
            score += 3   
        ans6 = stu_solution.explore(myBN,6)
        if (abs(ans6 - sol[5]) < wiggle):
            score += 3  
        if (ans5 < ans6):
            score += 2      

        details.add("problem_test_2:  {}".format(score))
    

    #details = "\n".join(details)    
    return score, details


# #@max_grade(2)
# def problem_test_2(stu_solution):
#     #stu_solution = student_modules[SOLUTION] 
#     details = set()
#     score = 0

#     model = stu_solution.NaiveBayesModel()
#     details.add(model)

#     details.add("problem_test_2:  {}".format(score))
#     #details = "\n".join(details)    
#     return 2*score, details


def create_test_results(name, output, marks_earned, marks_total):
    """Return a JSON string"""

    status = "pass" if marks_earned >= marks_total else "partial" if marks_earned > 0 else "fail"
    if marks_total == 0:
        status = 'fail'

    results = {"name": name,
               "output": output,
               "marks_earned": marks_earned,
               "marks_total": marks_total,
               "status": status
               }
    return results


def create_test_results_short(name, output, marks_earned, marks_total):
    """Return a JSON string"""

    status = "pass" if marks_earned >= marks_total else "partial" if marks_earned > 0 else "fail"
    if marks_total == 0:
        status = 'fail'

    results = {"name": name,
               #"output": output,
               "marks_earned": marks_earned,
               "marks_total": marks_total,
               "status": status
               }
    return results



def main():
    score, Details = minfill_test_1()  # max is  5
    print("Score is: {}\nDetails: {}".format(score, Details))
    score, Details = minfill_test_2()  # max is  5
    print("Score is: {}\nDetails: {}".format(score, Details))
    score, Details = nb_test_1()  # max is  5
    print("Score is: {}\nDetails: {}".format(score, Details))
    score, Details = nb_test_2()  # max is  5
    print("Score is: {}\nDetails: {}".format(score, Details))
    score, Details = problem_test_1()  # max is  5
    print("Score is: {}\nDetails: {}".format(score, Details))
    score, Details = problem_test_2()  # max is  5
    print("Score is: {}\nDetails: {}".format(score, Details))

if __name__ == '__main__':
    import json

    args = sys.argv
    name = args[1]
    student = args[2]

    # import student's functions
    try:
        module1_name = "remarks." + student + ".solution"
        module1 = importlib.import_module(module1_name)

        FOUND_SOLUTION = True
    except Exception:
        FOUND_SOLUTION = False
        IMPORT_ERROR = traceback.format_exc()


    if FOUND_SOLUTION is False:
        filename = student + "_results.txt"
        f = open(filename, "w")
        f.write(json.dumps(create_test_results("error", f"Could not import solution. {IMPORT_ERROR}", 0, 0)))
        f.close()

        exit()

    test_groups = {
        "test_minfill": [minfill_test_1, minfill_test_2],    
        "test_nb": [nb_test_1, nb_test_2],
        "test_problem": [problem_test_1, problem_test_2],
        "all": [nb_test_1, nb_test_2, minfill_test_1, minfill_test_2, problem_test_1]
    }

    test_case_weight = {
        nb_test_1: 10,  # worth 40%
        nb_test_2: 10,  # worth 40%
        problem_test_1: 20,  # worth 40%
        problem_test_2: 20,  # worth 40%
        minfill_test_1: 3,  # worth 40%
        minfill_test_2: 4  # worth 40%
    }

    filename = student + "_results.txt"
    f = open(filename, "w")
    f.close()

    gradefile = "A4.csv"
    g = open(gradefile, "a")

    filename = student + "_results.txt"
    f = open(filename, "a")
    results = []
    other = []
    for test in test_groups[name]:
        test_case_name = test.__name__
        weight = test_case_weight[test]
        try:
            score, details = test(module1)
            results.append(create_test_results(test_case_name,
                                                          details,
                                                          score, weight))
            other.append(create_test_results_short(test_case_name,
                                                          details,
                                                          score, weight))            
        except Exception:
            results.append(create_test_results(test_case_name,
                                                          traceback.format_exc(),
                                                          0, weight))
            other.append(create_test_results_short(test_case_name,
                                                          traceback.format_exc(),
                                                          0, weight))                                  
    total = 0
    g.write("{},".format(student))
    arr = []
    for item in results:
        f.write("***********************\n")
        f.write("Test: {}\n".format(item['name']))
        f.write("{}\n".format(item['output']))
        f.write("SCORE: {}/{}\n".format(item['marks_earned'],item['marks_total'],))
        arr.append(item['marks_earned'])
        g.write("{},".format(item['marks_earned']))
        total += int(item['marks_earned'])
        f.write("***********************\n")

    f.write("\n\n***********************\n")
    f.write("TOTAL: {}\n".format(total))
    f.write("***********************\n")
    f.close()
    g.write("\n")
    g.close()

    