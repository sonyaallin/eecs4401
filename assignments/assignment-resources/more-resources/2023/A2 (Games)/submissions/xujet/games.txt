What I learned in this assignment is how minimax selects the best value for the current user and outputs a move corresponding to the best possible move for that player's turn. What I also learned from this assignment is that finding an optimal move through minimax can be done much quicker by caching different states so that we do not have to encounter them again when going through a set of possible moves. This helps us look through less nodes and ultimately speed up the process. I learned that alpha-beta pruning is faster than minimax when it comes to finding an optimal move for the current player. It prunes different branches (or moves) that are not optimal to the current path and will therefore shorten the time to go through every possible moves to find the best move for the player by a large margin. Again, caching also helps to speed up the process by not going over previously cached moves.

What I found to be extremely challenging was first implementing minimax, as I was not using helper functions initially, but it became much clearer once I actually started to use helper functions for MAX player and MIN player. I also learned that you can use different heuristics to improve the chances of getting a player a win. I also learned that for MCTS trees, you can use UCB selection to find optimal successors for the player and allows for a much better chance at winning games for the player.