from bnetbase import Variable, Factor, BN
import csv
import itertools

def multiply_factors(Factors):
    '''Factors is a list of factor objects.
    Return a new factor that is the product of the factors in Factors.
    @return a factor''' 

    # start with the first factor
    factor = Factors[0]
    # multiply the rest of the factors
    for f in Factors[1:]:
        factor = multiply_factor(factor, f)
    return factor

def multiply_factor(f1, f2):
    '''f1 and f2 are factors. Return a new factor that is the product of f1 and f2.
    @return a factor'''
    new_factor = Factor(f1.name+'*'+f2.name, set(f1.scope+f2.scope))
    # Add values
    for assignment in itertools.product(*[v.domain() for v in new_factor.get_scope()]):
     for i, v in enumerate(new_factor.get_scope()):
         v.set_assignment(assignment[i])
     value = f1.get_value_at_current_assignments() * f2.get_value_at_current_assignments()
     new_factor.add_value_at_current_assignment(value)
    return new_factor

def restrict_factor(f, var, value):
    '''f is a factor, var is a Variable, and value is a value from var.domain.
    Return a new factor that is the restriction of f by this var = value.
    Don't change f! If f has only one variable its restriction yields a
    constant factor.
    @return a factor''' 
    restricted_scope = f.get_scope()
    if var not in restricted_scope:
        return f
    restricted_scope.remove(var)
    restricted_factor = Factor(f.name, restricted_scope)
    var.set_assignment(value)
    for assignment in itertools.product(*[v.domain() for v in restricted_scope]):
        for i, v in enumerate(restricted_scope):
            v.set_assignment(assignment[i])
        restricted_factor.add_value_at_current_assignment(f.get_value_at_current_assignments())
    return restricted_factor

def sum_out_variable(f, var):
    '''f is a factor, var is a Variable.
    Return a new factor that is the result of summing var out of f, by summing
    the function generated by the product over all values of var.
    @return a factor'''       
    summed_scope = f.get_scope()
    summed_scope.remove(var)
    summed_factor = Factor(f.name, summed_scope)
    for assignment in itertools.product(*[v.domain() for v in summed_scope]):
        for i, v in enumerate(summed_scope):
            v.set_assignment(assignment[i])
        sum = 0
        for value in var.domain():
            var.set_assignment(value)
            sum += f.get_value_at_current_assignments()
        summed_factor.add_value_at_current_assignment(sum)
    return summed_factor

def normalize(nums):
    '''num is a list of numbers. Return a new list of numbers where the new
    numbers sum to 1, i.e., normalize the input numbers.
    @return a normalized list of numbers'''
    # If negative numbers, shift all numbers up so that the minimum is 0
    minNum = min(nums)
    if min(nums)<0:
        nums = [num-minNum for num in nums]
    total = sum(nums)
    if total == 0:
        # If all numbers are 0, return a uniform distribution
        cons = 1/len(nums)
        return [cons]*len(nums)
    return [num/total for num in nums]


def min_fill_ordering(Factors, QueryVar):
    '''Factors is a list of factor objects, QueryVar is a query variable.
    Compute an elimination order given list of factors using the min fill heuristic. 
    Variables in the list will be derived from the scopes of the factors in Factors. 
    Order the list such that the first variable in the list generates the smallest
    factor upon elimination. The QueryVar must NOT part of the returned ordering list.
    @return a list of variables'''
    var_cts = {}
    families = [factor.get_scope() for factor in Factors]
    for f in families:
        if QueryVar in f:
            f.remove(QueryVar)
        for v in f:
            var_cts[v] = var_cts.get(v, 0) + 1
    var_cts.pop(QueryVar, None)

    ordering = []
    while len(var_cts) > 0:
        ordering.append(first_min_fill(families, var_cts))
    return ordering

def first_min_fill(families, var_cts):
    """Eliminate and return the variable that minimizes the number of new edges created
    after elimination and update families after merging the families involved with this hyperedge.
    """
    elim_var = min(var_cts, key=var_cts.get)
    new_family = set()
    for fam in families:
        if elim_var in fam:
            for v in fam:
                var_cts[v] = var_cts.get(v, 1) - 1
            new_family = new_family.union(fam)
            families.remove(fam)
    new_family.remove(elim_var)
    families.append(list(new_family))
    var_cts.pop(elim_var, None)
    return elim_var


def VE(Net, QueryVar, EvidenceVars):
    
    """
    Input: Net---a BN object (a Bayes Net)
           QueryVar---a Variable object (the variable whose distribution
                      we want to compute)
           EvidenceVars---a LIST of Variable objects. Each of these
                          variables has had its evidence set to a particular
                          value from its domain using set_evidence.
     VE returns a distribution over the values of QueryVar, i.e., a list
     of numbers, one for every value in QueryVar's domain. These numbers
     sum to one, and the i'th number is the probability that QueryVar is
     equal to its i'th value given the setting of the evidence
     variables. For example if QueryVar = A with Dom[A] = ['a', 'b',
     'c'], EvidenceVars = [B, C], and we have previously called
     B.set_evidence(1) and C.set_evidence('c'), then VE would return a
     list of three numbers. E.g. [0.5, 0.24, 0.26]. These numbers would
     mean that Pr(A='a'|B=1, C='c') = 0.5 Pr(A='a'|B=1, C='c') = 0.24
     Pr(A='a'|B=1, C='c') = 0.26
     @return a list of probabilities, one for each item in the domain of the QueryVar
     """
    Factors = Net.factors()
    for evidence in EvidenceVars:
        Factors = list(map(lambda f: restrict_factor(f, evidence, evidence.get_evidence()), Factors))

    ordering = min_fill_ordering(Factors, QueryVar)

    for var in ordering:
        # Get factors with var in scope
        factors_with_var = [f for f in Factors if var in f.get_scope()]
        Factors = [f for f in Factors if var not in f.get_scope()]
        # Multiply factors
        product = multiply_factors(factors_with_var)
        # Sum out var
        summed = sum_out_variable(product, var)
        Factors.append(summed)
    res = multiply_factors(Factors)
    probs = [res.get_value([v]) for v in QueryVar.domain()]
    return normalize(probs)


def NaiveBayesModel():
    '''
   NaiveBayesModel returns a BN that is a Naive Bayes model that 
   represents the joint distribution of value assignments to 
   variables in the Adult Dataset from UCI.  Remember a Naive Bayes model
   assumes P(X1, X2,.... XN, Class) can be represented as 
   P(X1|Class)*P(X2|Class)* .... *P(XN|Class)*P(Class).
   When you generated your Bayes Net, assume that the values 
   in the SALARY column of the dataset are the CLASS that we want to predict.
   @return a BN that is a Naive Bayes model and which represents the Adult Dataset. 
    '''
    ### READ IN THE DATA
    input_data = []
    with open('data/adult-dataset.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None) #skip header row
        for row in reader:
            input_data.append(row)

    ### DOMAIN INFORMATION REFLECTS ORDER OF COLUMNS IN THE DATA SET
    variable_domains = {
    "Work": ['Not Working', 'Government', 'Private', 'Self-emp'],
    "Education": ['<Gr12', 'HS-Graduate', 'Associate', 'Professional', 'Bachelors', 'Masters', 'Doctorate'],    
    "Occupation": ['Admin', 'Military', 'Manual Labour', 'Office Labour', 'Service', 'Professional'],    
    "MaritalStatus": ['Not-Married', 'Married', 'Separated', 'Widowed'],
    "Relationship": ['Wife', 'Own-child', 'Husband', 'Not-in-family', 'Other-relative', 'Unmarried'],
    "Race": ['White', 'Black', 'Asian-Pac-Islander', 'Amer-Indian-Eskimo', 'Other'],
    "Gender": ['Male', 'Female'],
    "Country": ['North-America', 'South-America', 'Europe', 'Asia', 'Middle-East', 'Carribean'],
    "Salary": ['<50K', '>=50K']
    }
    ### YOUR CODE HERE ###

    # Create variables
    salaryVar = Variable("Salary", variable_domains["Salary"])
    variables = []
    for var_name, domain in variable_domains.items():
        if var_name != "Salary":
            variables.append(Variable(var_name, domain))
    # Create factors
    factors = []
    for var in variables:
        f = Factor(f"P({var.name}|Salary)", [var, salaryVar])
        values = []
        for val, salary in itertools.product(var.domain(), salaryVar.domain()):
            p = get_cond_probability(input_data, headers, var.name, val, "Salary", salary)
            values.append([val, salary, p])
        f.add_values(values)
        factors.append(f)
    # Create salary factor
    f = Factor("P(Salary)", [salaryVar])
    values = []
    for salary in salaryVar.domain():
        p = get_probability(input_data, headers, "Salary", salary)
        values.append([salary, p])
    f.add_values(values)
    factors.append(f)
    variables.append(salaryVar)
    # Create BN
    bn = BN("NBTrain", variables, factors)

    return bn

def get_probability(input_data, headers, var_name, val):
    '''
    Input: input_data---a list of lists, where each inner list is a row of the data set
    headers---a list of strings, where each string is the name of a column in the data set
    var_name---a string, the name of the variable for which we want to calculate the probability
    val---a string, the value of the variable for which we want to calculate the probability
    Output: a float, the probability of the variable taking on the given value
    '''
    count = 0
    for row in input_data:
        if row[headers.index(var_name)] == val:
            count += 1
    return count / len(input_data)

def get_cond_probability(input_data, headers, var_name, val, cond_name, cond_val):
    '''
    Input: input_data---a list of lists, where each inner list is a row of the data set
    headers---a list of strings, where each string is the name of a column in the data set
    var_name---a string, the name of the variable for which we want to calculate the probability
    val---a string, the value of the variable for which we want to calculate the probability
    cond_name---a string, the name of the variable that is the condition
    cond_val---a string, the value of the variable that is the condition
    Output: a float, the conditional probability of the variable taking on the given value given the condition
    '''
    count = cond_ct = 0
    for row in input_data:
        if row[headers.index(cond_name)] == cond_val and row[headers.index(var_name)] == val:
            count += 1
        if row[headers.index(cond_name)] == cond_val:
            cond_ct += 1
    return count / cond_ct

def Explore(Net, question):
    '''    Input: Net---a BN object (a Bayes Net)
           question---an integer indicating the question in HW4 to be calculated. Options are:
           1. What percentage of the women in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           2. What percentage of the men in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           3. What percentage of the women in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           4. What percentage of the men in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           5. What percentage of the women in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           6. What percentage of the men in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           @return a percentage (between 0 and 100)

    Answers:
    99.95929167514757
    0.0
    57.32323232323232
    66.30476929042266
    8.0602483207816
    25.41888428937512
    '''
    input_data = []
    with open('data/test-data.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None) #skip header row
        for row in reader:
            input_data.append(row)

    E1Vars = [Net.get_variable(v) for v in ['Work', 'Occupation', 'Education', 'Relationship']]
    E2Vars = E1Vars + [Net.get_variable('Gender')]
    salaryVar = Net.get_variable("Salary")

    PSalaryE1 = []
    PSalaryE2 = []

    # Predict P(Salary|E1) and P(Salary|E2) for each row in the test data set
    for row in input_data:
        # Set evidence
        for var in E2Vars:
            var.set_evidence(row[headers.index(var.name)])
        f1 = VE(Net, salaryVar, E1Vars)
        f2 = VE(Net, salaryVar, E2Vars)
        # Calculate P(Salary|E1) and P(Salary|E2)
        PSalaryE1.append(f1)
        PSalaryE2.append(f2)

    # Index of Gender in csv data
    genderIndex = headers.index('Gender')
    # Index of >=50K in salary domain
    SGTIndex = salaryVar.domain().index(">=50K")

    if question == 1:
        # What percentage of the women in the test data set end up with a P(S=">=$50K"|E1)
        # that is strictly greater than P(S=">=$50K"|E2)?
        count = total = 0
        for i, row in enumerate(input_data):
            if row[genderIndex] == 'Female':
                total += 1
                PSGreaterE1 = PSalaryE1[i][SGTIndex]
                PSGreaterE2 = PSalaryE2[i][SGTIndex]
                if PSGreaterE1 > PSGreaterE2:
                    count += 1
        return count / total * 100
    elif question == 2:
        # What percentage of the men in the test data set end up with a P(S=">=$50K"|E1)
        # that is strictly greater than P(S=">=$50K"|E2)?
        count = total = 0
        for i, row in enumerate(input_data):
            if row[genderIndex] == 'Male':
                total += 1
                PSGreaterE1 = PSalaryE1[i][SGTIndex]
                PSGreaterE2 = PSalaryE2[i][SGTIndex]
                if PSGreaterE1 > PSGreaterE2:
                    count += 1
        return count / total * 100
    elif question == 3:
       # What percentage of the women in the test data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
        count = total = 0
        for i, row in enumerate(input_data):
            if row[genderIndex] == 'Female':
                PSGreaterE1 = PSalaryE1[i][SGTIndex]
                if PSGreaterE1 > 0.5:
                    total += 1
                    if row[headers.index('Salary')] == ">=50K":
                        count += 1
        return count / total * 100
    elif question == 4:
       # What percentage of the men in the test data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
        count = total = 0
        for i, row in enumerate(input_data):
            if row[genderIndex] == 'Male':
                PSGreaterE1 = PSalaryE1[i][SGTIndex]
                if PSGreaterE1 > 0.5:
                    total += 1
                    if row[headers.index('Salary')] == ">=50K":
                        count += 1
        return count / total * 100
    elif question == 5:
        # What percentage of the women in the test data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
        count = total = 0
        for i, row in enumerate(input_data):
            if row[genderIndex] == 'Female':
                total += 1
                PSGreaterE1 = PSalaryE1[i][SGTIndex]
                if PSGreaterE1 > 0.5:
                    count += 1
        return count / total * 100
    elif question == 6:
        # What percentage of the men in the test data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
        count = total = 0
        for i, row in enumerate(input_data):
            if row[genderIndex] == 'Male':
                total += 1
                PSGreaterE1 = PSalaryE1[i][SGTIndex]
                if PSGreaterE1 > 0.5:
                    count += 1
        return count / total * 100
    else:
        raise ValueError("Invalid question number")

# if __name__ == "__main__":
#     Nb = NaiveBayesModel()
#     for i in range(1, 7):
#         print(Explore(Nb, i))
