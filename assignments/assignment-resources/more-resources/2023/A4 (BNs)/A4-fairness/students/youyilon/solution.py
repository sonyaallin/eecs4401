from bnetbase import Variable, Factor, BN
import csv
import itertools

def multiply_factors(Factors):
    '''Factors is a list of factor objects.
    Return a new factor that is the product of the factors in Factors.
    @return a factor''' 
    ### YOUR CODE HERE ###
    seen_vars = set()
    scope = []
    domains = []  # 2d array for the use of itertools.product()

    for factor in Factors:
        for i in range(len(factor.scope)):
            if factor.scope[i] not in seen_vars:
                seen_vars.add(factor.scope[i])
                scope.append(factor.scope[i])
                domains.append(factor.scope[i].domain())
    product = Factor("product", scope)
    assignments = [a for a in itertools.product(*domains)]  # all possible combinations of assignments

    scope_len = len(scope)
    for asmt in assignments:
        value = 1
        for i in range(scope_len):
            scope[i].set_assignment(asmt[i])  # assign all variables so their values can be looked up from Factors
        for factor in Factors:
            value *= factor.get_value_at_current_assignments()
        product.add_value_at_current_assignment(value)

    return product


def restrict_factor(f, var, value):
    '''f is a factor, var is a Variable, and value is a value from var.domain.
    Return a new factor that is the restriction of f by this var = value.
    Don't change f! If f has only one variable its restriction yields a
    constant factor.
    @return a factor''' 
    ### YOUR CODE HERE ###
    var.set_assignment(value)

    if len(f.get_scope()) == 1:
        restricted = Factor("Const", [])
        restricted.add_values([[f.get_value_at_current_assignments()]])
        return restricted

    scope = f.get_scope()
    scope.remove(var)
    domains = []
    for v in scope:
        domains.append(v.domain())
    assignments = [a for a in itertools.product(*domains)]  # All possible assignments without var, which is already assigned
    new = Factor("Restricted", scope)
    for asmt in assignments:
        for i in range(len(scope)):
            scope[i].set_assignment(asmt[i])
        new.add_value_at_current_assignment(f.get_value_at_current_assignments())
    return new


def sum_out_variable(f, var):
    '''f is a factor, var is a Variable.
    Return a new factor that is the result of summing var out of f, by summing
    the function generated by the product over all values of var.
    @return a factor'''       
    ### YOUR CODE HERE ###
    restricted_factors = []
    for val in var.domain():
        restricted_factors.append(restrict_factor(f, var, val))

    scope = f.get_scope()
    scope.remove(var)
    domains = []
    for v in scope:
        domains.append(v.domain())
    new = Factor("Summed out", scope)
    assignments = [a for a in itertools.product(*domains)]
    for asmt in assignments:
        for i in range(len(scope)):
            scope[i].set_assignment(asmt[i])
        sum = 0
        for r_factor in restricted_factors:
            sum += r_factor.get_value_at_current_assignments()
        new.add_value_at_current_assignment(sum)
    return new


def normalize(nums):
    '''num is a list of numbers. Return a new list of numbers where the new
    numbers sum to 1, i.e., normalize the input numbers.
    @return a normalized list of numbers'''
    ### YOUR CODE HERE ###
    total = sum(nums)
    for i in range(len(nums)):
        nums[i] /= total
    return nums


def min_fill_ordering(Factors, QueryVar):
    '''Factors is a list of factor objects, QueryVar is a query variable.
    Compute an elimination order given list of factors using the min fill heuristic. 
    Variables in the list will be derived from the scopes of the factors in Factors. 
    Order the list such that the first variable in the list generates the smallest
    factor upon elimination. The QueryVar must NOT part of the returned ordering list.
    @return a list of variables''' 
    ### YOUR CODE HERE ###
    vars= {}
    for factor in Factors:
        scope = factor.get_scope()
        for var in scope:
            if var == QueryVar:
                continue
            if var not in vars:
                vars[var] = set()
            vars[var].update(scope)  # Counts the number of unique variables that are ever in the same
                                     # hyperedge as var. The order of the number of related variables
                                     # should not change even if var is not deleted.
    for var in vars.keys():
        vars[var] = len(vars[var])

    return [var for var, f_size in sorted(vars.items(), key=lambda pair: pair[1])]


def VE(Net, QueryVar, EvidenceVars):
    
    """
    Input: Net---a BN object (a Bayes Net)
           QueryVar---a Variable object (the variable whose distribution
                      we want to compute)
           EvidenceVars---a LIST of Variable objects. Each of these
                          variables has had its evidence set to a particular
                          value from its domain using set_evidence.
     VE returns a distribution over the values of QueryVar, i.e., a list
     of numbers, one for every value in QueryVar's domain. These numbers
     sum to one, and the i'th number is the probability that QueryVar is
     equal to its i'th value given the setting of the evidence
     variables. For example if QueryVar = A with Dom[A] = ['a', 'b',
     'c'], EvidenceVars = [B, C], and we have previously called
     B.set_evidence(1) and C.set_evidence('c'), then VE would return a
     list of three numbers. E.g. [0.5, 0.24, 0.26]. These numbers would
     mean that Pr(A='a'|B=1, C='c') = 0.5 Pr(A='b'|B=1, C='c') = 0.24
     Pr(A='c'|B=1, C='c') = 0.26
     @return a list of probabilities, one for each item in the domain of the QueryVar
     """
    ### YOUR CODE HERE ###
    for var in EvidenceVars:
        if not isinstance(var, Variable):
            raise ValueError("EvidenceVars in VE() has to be Variable objects")
    factors = Net.factors()
    # Restrict factors that contains evidence
    for i in range(len(factors)):
        contained_evidence = set(factors[i].get_scope()).intersection(set(EvidenceVars))
        if len(contained_evidence) > 0:
            for e in contained_evidence:
                factors[i] = restrict_factor(factors[i], e, e.get_evidence())

    # Delete variables, create new hyperedges, delete previous hyperedges related to the deleted variables
    removal_order = min_fill_ordering(factors, QueryVar)
    for var in removal_order:
        related_factors = []
        for factor in factors:
            if var in factor.get_scope():
                related_factors.append(factor)
        factor_to_add = sum_out_variable(multiply_factors(related_factors), var)
        factors = [f for f in factors if f not in related_factors]
        factors.append(factor_to_add)

    # Multiply remaining factors and normalize
    product = multiply_factors(factors)
    if product.get_scope()[0] != QueryVar:
        print("scope[0] is not QueryVar")
        print("Scope: ", product.get_scope()[0], "QueryVar: ", QueryVar)
    probabilities = []
    for val in product.get_scope()[0].domain():
        QueryVar.set_assignment(val)
        probabilities.append(product.get_value_at_current_assignments())

    return normalize(probabilities)


def NaiveBayesModel():
    """
    NaiveBayesModel returns a BN that is a Naive Bayes model that
    represents the joint distribution of value assignments to
    variables in the Adult Dataset from UCI.  Remember a Naive Bayes model
    assumes P(X1, X2,.... XN, Class) can be represented as
    P(X1|Class)*P(X2|Class)* .... *P(XN|Class)*P(Class).
    When you generated your Bayes Net, assume that the values
    in the SALARY column of the dataset are the CLASS that we want to predict.
    @return a BN that is a Naive Bayes model and which represents the Adult Dataset.
    """
    ### READ IN THE DATA
    input_data = []
    with open('data/adult-dataset.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None) #skip header row
        for row in reader:
            input_data.append(row)

    ### DOMAIN INFORMATION REFLECTS ORDER OF COLUMNS IN THE DATA SET
    variable_domains = {
    "Work": ['Not Working', 'Government', 'Private', 'Self-emp'],
    "Education": ['<Gr12', 'HS-Graduate', 'Associate', 'Professional', 'Bachelors', 'Masters', 'Doctorate'],
    "MaritalStatus": ['Not-Married', 'Married', 'Separated', 'Widowed'],
    "Occupation": ['Admin', 'Military', 'Manual Labour', 'Office Labour', 'Service', 'Professional'],
    "Relationship": ['Wife', 'Own-child', 'Husband', 'Not-in-family', 'Other-relative', 'Unmarried'],
    "Race": ['White', 'Black', 'Asian-Pac-Islander', 'Amer-Indian-Eskimo', 'Other'],
    "Gender": ['Male', 'Female'],
    "Country": ['North-America', 'South-America', 'Europe', 'Asia', 'Middle-East', 'Carribean'],
    "Salary": ['<50K', '>=50K']
    }
    ### YOUR CODE HERE ###
    # Initiate variables
    variables = []
    for name, domain in variable_domains.items():
        variables.append(Variable(name, domain))

    # Count the number of times each value appeared
    values = list(variable_domains.values())
    value_counts = [[0] * len(dom) for dom in variable_domains.values()]
    for person in input_data:
        for i in range(len(person)):
            value_counts[i][values[i].index(person[i])] += 1

    # Generate factors, each factor only contains another variable and salary. The last factor only contains salary.
    factors = []
    for i in range(len(variables) - 1):
        # This is the input for Factor.add_values(), containing all possible assignments of variables[i], salary,
        # and the values associated with each assignment.
        assignments = [[values[i][j1], values[-1][j2], value_counts[i][j1]/value_counts[-1][j2]]
                       for j1 in range(len(values[i])) for j2 in range(len(values[-1]))]
        f = Factor(variables[i].name, [variables[i], variables[-1]])
        f.add_values(assignments)
        factors.append(f)
    prior_factor = Factor("Salary", [variables[-1]])
    prior_factor.add_values([[values[-1][0], value_counts[-1][0]], [values[-1][1], value_counts[-1][1]]])
    factors.append(prior_factor)

    # Create the BN and return it!
    return BN("Adult dataset", variables, factors)


def Explore(Net, question):
    '''    Input: Net---a BN object (a Bayes Net)
           question---an integer indicating the question in HW4 to be calculated. Options are:
           1. What percentage of the women in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           2. What percentage of the men in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           3. What percentage of the women in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           4. What percentage of the men in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           5. What percentage of the women in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           6. What percentage of the men in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           @return a percentage (between 0 and 100)
    ''' 
    ### YOUR CODE HERE ###
    input_data = []
    with open('data/test-data.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None)
        indices = [0, 1, 3, 4, 6, 8]  # 6 is gender, 8 is salary
        variables = [Net.get_variable(headers[i]) for i in indices]
        for row in reader:
            row = [row[i] for i in indices]
            input_data.append(row)
    csvfile.close()

    correct = 0
    evidences2 = variables[:-1]
    evidences1 = variables[:-2]
    if question == 1:
        data = [person for person in input_data if person[-2] == "Female"]
        counter = 0
        for person in data:
            E2 = person[:-1]
            for i in range(len(E2)):
                evidences2[i].set_evidence(E2[i])
            probs1 = VE(Net, variables[-1], evidences1)
            prob1 = probs1[1]  # The probability that salary == ">=$50K"
            prob2 = VE(Net, variables[-1], evidences2)[1]
            print(prob1, prob2)
        #     if prob1 > prob2:
        #         counter += 1

        #     pred1 = "<50K" if probs1[0] > probs1[1] else ">=50K"
        #     if pred1 == person[-1]:
        #         correct += 1
        #     else:
        #        print(pred1, person[-1])
        # print(correct / len(data), "%, or ", correct, " out of ", len(data), ", of prediction with E1 are correct.")

        return counter / len(data)



print(Explore(NaiveBayesModel(), 1))