from bnetbase import Variable, Factor, BN
import csv

def multiply_factors(Factors):
    '''Factors is a list of factor objects.
    Return a new factor that is the product of the factors in Factors.
    @return a factor''' 
    ### YOUR CODE HERE ###
    # Initialize new factor's name
    new_name = ''

    # Update the name and get all variables of factors
    vars = []
    for factor in Factors:
        new_name += factor.name
        new_name += " * "
        vars.extend(factor.get_scope())
    
    # Update the name
    new_name = new_name[:-3]
    
    # Initialize new factor's scope and Delete the duplicated common variables
    new_scope = list(set(vars))
 
    # Create a new Factor object with the new scope
    new_factor = Factor(new_name, new_scope)
    
    # Recursively assign values to variables
    def recursion_assignment(vars):
        # All variables have been assigned. Calculate the production
        if len(vars) == 0:
            result = 1
            for factor in Factors:
                # According to assigned variable, get the value of current factor
                result *= factor.get_value_at_current_assignments()
            
            # Update the new_factor's value with all assigned variables
            new_factor.add_value_at_current_assignment(result)
        
        else:
            
            for val in vars[0].domain():
                # Assign variables from domain
                vars[0].set_assignment(val)
                # According constant assignment vars[0], recursively assign 
                # following variables until all variables are assigned
                recursion_assignment(vars[1:])

    recursion_assignment(new_scope)
    return new_factor
    
def restrict_factor(f, var, value):
    '''f is a factor, var is a Variable, and value is a value from var.domain.
    Return a new factor that is the restriction of f by this var = value.
    Don't change f! If f has only one variable its restriction yields a
    constant factor.
    @return a factor''' 
    ### YOUR CODE HERE ###
    # Initialize new factor's name
    new_name = ''
    for i in f.name:
        new_name += i
        if i == var.name:
            new_name += "=" + str(value)

    # Initialize the new factor's scope
    new_scope = []
    for v in f.get_scope():
        if v == var:
            v.set_assignment(value)
        new_scope.append(v)

    # Initialize new factor
    new_factor = Factor(new_name, new_scope)
    
    # Recursively assign values to variables expect the var(already assigned)
    def recursion_assign_expect(vars, var):
        # Every variables have been assigned
        if len(vars) == 0:
            new_factor.add_value_at_current_assignment(f.get_value_at_current_assignments())
        else:
            # If vars[0] is the restrict variable, pass it go to next level
            if vars[0] == var:
                recursion_assign_expect(vars[1:], var)
            else:
                for val in vars[0].domain():
                    vars[0].set_assignment(val)
                    recursion_assign_expect(vars[1:], var)

    recursion_assign_expect(new_scope, var)
    return new_factor


def sum_out_variable(f, var):
    '''f is a factor, var is a Variable.
    Return a new factor that is the result of summing var out of f, by summing
    the function generated by the product over all values of var.
    @return a factor'''       
    ### YOUR CODE HERE ###
    # Initialize new factor's name
    new_name = ''
    for i in f.name:
        if i != var.name:
            new_name += i
    
    # Initialize the new factor's scope
    new_scope = []
    for v in f.get_scope():
        if v != var:
            new_scope.append(v)
    
    # Initialize new factor
    new_factor = Factor(new_name, new_scope)

    # Recursively assign values to variables
    def recursion_assignment_sumout(vars):
        # All variables have been assigned. Calculate the sumout
        if len(vars) == 0:
            sumout = 0
            # set value to var from var.dom
            for val in var.dom:
                var.set_assignment(val)
                sumout += f.get_value_at_current_assignments()
            # Update the new_factor's value with all assigned variables
            new_factor.add_value_at_current_assignment(sumout)
        else:     
            for val in vars[0].domain():
                # Assign variables from domain
                vars[0].set_assignment(val)
                # According constant assignment vars[0], recursively assign 
                # following variables until all variables are assigned
                recursion_assignment_sumout(vars[1:])

    recursion_assignment_sumout(new_scope)  
    return new_factor


def normalize(nums):
    '''num is a list of numbers. Return a new list of numbers where the new
    numbers sum to 1, i.e., normalize the input numbers.
    @return a normalized list of numbers'''
    ### YOUR CODE HERE ###
    total = sum(nums)

    norm = []
    for i in nums:
        if total == 0:
            norm.append(0)
        else:
            norm.append(i/total)
    
    return norm

def min_fill_ordering(Factors, QueryVar):
    '''Factors is a list of factor objects, QueryVar is a query variable.
    Compute an elimination order given list of factors using the min fill heuristic. 
    Variables in the list will be derived from the scopes of the factors in Factors. 
    Order the list such that the first variable in the list generates the smallest
    factor upon elimination. The QueryVar must NOT part of the returned ordering list.
    @return a list of variables''' 
    ### YOUR CODE HERE ###
    # Create a list of all variables in the scopes of the factors except QueryVar
    variables = []
    for factor in Factors:
        for var in factor.get_scope():
            if var not in variables and var != QueryVar:
                variables.append(var)
    
    # Initialize the orderd variable list
    orderd_vars = []
    
    # While there are still variables left to eliminate
    while len(variables) != 0:
        # Initialize the smallest size factor
        min_factor_size = float("inf")
        # Initialize the variable has the smallest size factor
        min_factor_var = None
        
        for var in variables:
            # Initialize the relation variable lists
            related_var = []
            for factor in Factors:
                # Check var in factor's scope
                if var in factor.get_scope():
                    for v in factor.get_scope():
                        # To calculate how many edges of var
                        if v not in related_var and v != var:
                            related_var.append(v)

            # Update the min factor size          
            if len(related_var) < min_factor_size:
                min_factor_size = len(related_var)
                min_factor_var = var
        
        orderd_vars.append(min_factor_var)
        variables.remove(min_factor_var)

    return orderd_vars

def VE(Net, QueryVar, EvidenceVars):
    
    """
    Input: Net---a BN object (a Bayes Net)
           QueryVar---a Variable object (the variable whose distribution
                      we want to compute)
           EvidenceVars---a LIST of Variable objects. Each of these
                          variables has had its evidence set to a particular
                          value from its domain using set_evidence.
     VE returns a distribution over the values of QueryVar, i.e., a list
     of numbers, one for every value in QueryVar's domain. These numbers
     sum to one, and the i'th number is the probability that QueryVar is
     equal to its i'th value given the setting of the evidence
     variables. For example if QueryVar = A with Dom[A] = ['a', 'b',
     'c'], EvidenceVars = [B, C], and we have previously called
     B.set_evidence(1) and C.set_evidence('c'), then VE would return a
     list of three numbers. E.g. [0.5, 0.24, 0.26]. These numbers would
     mean that Pr(A='a'|B=1, C='c') = 0.5 Pr(A='a'|B=1, C='c') = 0.24
     Pr(A='a'|B=1, C='c') = 0.26
     @return a list of probabilities, one for each item in the domain of the QueryVar
     """
    ### YOUR CODE HERE ###
    # Initialize F be factors in original CPTs.
    F = Net.factors()

    # Replace each factor factor in F that mentions a variabe in E
    replaced = []
    for factor in F:
        for e in EvidenceVars:
            if e in factor.get_scope():
                new_factor = restrict_factor(factor, e, e.get_evidence())
                replaced.append(new_factor)
            else:
                replaced.append(factor)

    F = replaced
    
    # Initialize the remaining variables Z
    Z = min_fill_ordering(F, QueryVar)
    
    for z in Z:
        # Get all f_i in F contains z
        Factors = []
        for factor in F:
            if z in factor.get_scope():
                Factors.append(factor)
        
        # Compute the new factor g
        g = sum_out_variable(multiply_factors(Factors), z)

        # remove the factors f_i mentioned z
        removed = []
        for factor in F:
            if z not in factor.get_scope():
                removed.append(factor)
        
        F = removed
        
        # Add new factor g to F
        F.append(g)
    
    new_factor = multiply_factors(F)
    return normalize(new_factor.values)
    
def NaiveBayesModel():
    '''
   NaiveBayesModel returns a BN that is a Naive Bayes model that 
   represents the joint distribution of value assignments to 
   variables in the Adult Dataset from UCI.  Remember a Naive Bayes model
   assumes P(X1, X2,.... XN, Class) can be represented as 
   P(X1|Class)*P(X2|Class)* .... *P(XN|Class)*P(Class).
   When you generated your Bayes Net, assume that the values 
   in the SALARY column of the dataset are the CLASS that we want to predict.
   @return a BN that is a Naive Bayes model and which represents the Adult Dataset. 
    '''
    ### READ IN THE DATA
    input_data = []
    with open('data/adult-dataset.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None) #skip header row
        for row in reader:
            input_data.append(row)

    ### DOMAIN INFORMATION REFLECTS ORDER OF COLUMNS IN THE DATA SET
    variable_domains = {
    "Work": ['Not Working', 'Government', 'Private', 'Self-emp'],
    "Education": ['<Gr12', 'HS-Graduate', 'Associate', 'Professional', 'Bachelors', 'Masters', 'Doctorate'],    
    "Occupation": ['Admin', 'Military', 'Manual Labour', 'Office Labour', 'Service', 'Professional'],    
    "MaritalStatus": ['Not-Married', 'Married', 'Separated', 'Widowed'],
    "Relationship": ['Wife', 'Own-child', 'Husband', 'Not-in-family', 'Other-relative', 'Unmarried'],
    "Race": ['White', 'Black', 'Asian-Pac-Islander', 'Amer-Indian-Eskimo', 'Other'],
    "Gender": ['Male', 'Female'],
    "Country": ['North-America', 'South-America', 'Europe', 'Asia', 'Middle-East', 'Carribean'],
    "Salary": ['<50K', '>=50K']
    }
    ### YOUR CODE HERE ###
    # Initialize variables in variable_domains
    variables = {}
    for name, dom in variable_domains.items():
        variables[name] = Variable(name, dom)
        

    # Initialize factors
    Factors = []
    # Create factor for the Salary
    salary_factor = Factor("P(Salary)", [variables["Salary"]])

    # Calculate the numbers of '<50K'
    less = 0
    # Calculate the numbers of '>=50K'
    greater = 0
    for row in input_data:
        if row[-1] == '<50K':
            less += 1
        else:
            greater += 1
    
    # Calculate the probability
    less_values = ['<50K', less/len(input_data)]
    greater_values = ['>=50K', greater/len(input_data)]
    # Updating the values
    salary_factor.add_values([less_values, greater_values])
    # Adding the factor to the list
    Factors.append(salary_factor)
    
    # Orderd the variables name based on the header of csv file
    names = []
    for i in headers[:-1]:
        names.append(i)

    # record name's index
    index = 0
    for name in names:
        # Get the variables to create factor
        vars = [variables[name], variables["Salary"]]
        # Initialize the factor
        f = Factor("P({}|Salary)".format(name), vars)
        # Initialize the counts dictionary
        counts = {}
        for dom in variables[name].domain():
            # counts[dom][0] = # of (dom and <50K)
            # counts[dom][1] = # of (dom and >=50K)
            counts[dom] = [0, 0]
        
        for row in input_data:
            # Count the numbers of (row[index] and '<50K')
            if row[-1] == '<50K':
                counts[row[index]][0] += 1
            # Count the numbers of (row[index] and '>=50K')
            else:
                counts[row[index]][1] += 1

        values = []
        for dom in variables[name].domain():
            # Calculate the probability of P(row[index]|Salary)
            # (# of (dom and <50K))/(# of <50K)
            v1 = [dom, '<50K', counts[dom][0]/less]
            # (# of (dom and >=50K))/(# of >=50K)
            v2 = [dom, '>=50K', counts[dom][1]/greater]
            values.append(v1)
            values.append(v2)

            # Updating the values
            f.add_values(values)
            # Adding the factor to the list
            Factors.append(f)
        
        index += 1

    vars = []
    for v in variables.values():
        vars.append(v)
    
    return BN("Adult Salary", vars, Factors)

def Explore(Net, question):
    '''    Input: Net---a BN object (a Bayes Net)
           question---an integer indicating the question in HW4 to be calculated. Options are:
           1. What percentage of the women in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           2. What percentage of the men in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           3. What percentage of the women in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           4. What percentage of the men in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           5. What percentage of the women in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           6. What percentage of the men in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           @return a percentage (between 0 and 100)
    ''' 
    ### YOUR CODE HERE ###
    # Read in the data
    input_data = []
    with open('data/test-data.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None) #skip header row
        for row in reader:
            input_data.append(row)

    QueryVar = Net.get_variable("Salary")
    EvidenceVars1 = []
    index1 = []
    for var in ["Work", "Occupation", "Education", "Relationship"]:
        EvidenceVars1.append(Net.get_variable(var))
        index1.append(headers.index(var))
    
    EvidenceVars2 = []
    index2 = []
    for var in ["Work", "Occupation", "Education", "Relationship", "Gender"]:
        EvidenceVars2.append(Net.get_variable(var))
        index2.append(headers.index(var))

    count = 0
    total = 0
    for row in input_data:
        
        for i in range(len(EvidenceVars1)):
            e = EvidenceVars1[i]
            e.set_evidence(row[index1[i]])
        
        for i in range(len(EvidenceVars2)):
            e = EvidenceVars2[i]
            e.set_evidence(row[index2[i]])

        if question == 1:
            p1 = VE(Net, QueryVar, EvidenceVars1)[1]
            p2 = VE(Net, QueryVar, EvidenceVars2)[1]
            if row[6] == "Female" and p1 > p2:
                count += 1
            if row[6] == "Female":
                total += 1

        elif question == 2:
            p1 = VE(Net, QueryVar, EvidenceVars1)[1]
            p2 = VE(Net, QueryVar, EvidenceVars2)[1]
            if row[6] == "Male" and p1 > p2:
                count += 1
            if row[6] == "Male":
                total += 1
        
        elif question == 3:
            p1 = VE(Net, QueryVar, EvidenceVars1)[1]
            if row[6] == "Female" and p1 > 0.5 and row[-1] == ">=50K":
                count += 1
            if row[6] == "Female":
                total += 1
        
        elif question == 4:
            p1 = VE(Net, QueryVar, EvidenceVars1)[1]
            if row[6] == "Male" and p1 > 0.5 and row[-1] == ">=50K":
                count += 1
            if row[6] == "Male":
                total += 1
        
        elif question == 5:
            p1 = VE(Net, QueryVar, EvidenceVars1)[1]
            if row[6] == "Female" and p1 > 0.5:
                count += 1
            if row[6] == "Female":
                total += 1
        
        elif question == 6:
            p1 = VE(Net, QueryVar, EvidenceVars1)[1]
            if row[6] == "Male" and p1 > 0.5:
                count += 1
            if row[6] == "Male":
                total += 1

    return (count/total) * 100

