#!/usr/bin/env python
# coding: utf-8

from bnetbase import Variable, Factor, BN
import csv


def multiply_factors(Factors):
    '''Factors is a list of factor objects.
    Return a new factor that is the product of the factors in Factors.
    @return a factor'''
    '''
    each factor is a function of some variables where it maps each value of its arguments onto a number 
    e.g. P(C|A) = f(A, C) 
    
    If we examine the summation process we will see that various operations repeatedly occur on factors 
    
    Notation: f(X, Y) denotes a factor over the variables X and Y where X and Y are sets of variables 
    
    If we got two factors and we want to make another factor that is the multiplication of the two of them 
    
    Take the two tables that represent the two factors and you multiply them together 
    '''
    # Get the name and scope of the new factor
    # create the new name
    new_factor_name = ''
    for factor in Factors:
        new_factor_name += factor.name

    # New scope containing all of the newer variables  - make sure not to include a variable more than once
    new_factor_scope = list(set(variable for factor in Factors for variable in factor.get_scope()))

    # Initialize the new factor
    new_factor = Factor(new_factor_name, new_factor_scope)

    def product_of_factors(current_scope):
        # Base case: calculate the multiplication
        if not current_scope:
            product = 1
            for factor in Factors:
                product *= factor.get_value_at_current_assignments()
            new_factor.add_value_at_current_assignment(product)

        # Assign a variable with values from its domain and recursively assign values to unassigned variables
        else:
            current_variable = current_scope[-1]
            for value in current_variable.domain():
                current_variable.set_assignment(value)
                product_of_factors(current_scope[:-1])

    # Recursively multiply the factors
    product_of_factors(new_factor_scope)

    return new_factor


def restrict_factor(f, var, value):
    '''f is a factor, var is a Variable, and value is a value from var.domain.
    Return a new factor that is the restriction of f by this var = value.
    Don't change f! If f has only one variable its restriction yields a
    constant factor.
    @return a factor'''
    new_factor_name = "restrict {} with {}".format(var.name, value)

    # still remove the variable from the given scope
    new_factor_scope = []
    for scope in f.get_scope():
        if scope.name != var.name:
            new_factor_scope.append(scope)

    # Initialize the new factor
    new_factor = Factor(new_factor_name, new_factor_scope)

    def restricting_a_factor(current_scope):
        if not current_scope:
            # assign the restricted variable with that particular value then grab the current assignment of those values
            var.set_assignment(value)
            total = f.get_value_at_current_assignments()
            new_factor.add_value_at_current_assignment(total)
        else:
            current_variable = current_scope[-1]
            for val in current_variable.domain():
                current_variable.set_assignment(val)
                restricting_a_factor(current_scope[:-1])

    restricting_a_factor(new_factor_scope)

    return new_factor


def sum_out_variable(f, var):
    '''f is a factor, var is a Variable.
    Return a new factor that is the result of summing var out of f, by summing
    the function generated by the product over all values of var.
    @return a factor'''
    '''
    factors may not sum to one because they are illegal probability distributions 
    '''
    new_factor_name = "remove {}".format(var.name)
    new_factor_scope = []
    for scope in f.get_scope():
        if scope.name != var.name:
            new_factor_scope.append(scope)

    # Initialize the new factor
    new_factor = Factor(new_factor_name, new_factor_scope)

    def summing_variable_out_of_factor(current_scope):
        # when all values are assigned
        if not current_scope:
            total = 0
            for domain in var.domain():
                var.set_assignment(domain)
                total += f.get_value_at_current_assignments()
            new_factor.add_value_at_current_assignment(total)
        else:
            current_variable = current_scope[-1]
            for value in current_variable.domain():
                current_variable.set_assignment(value)
                summing_variable_out_of_factor(current_scope[:-1])

    summing_variable_out_of_factor(new_factor_scope)

    return new_factor


def normalize(nums):
    '''num is a list of numbers. Return a new list of numbers where the new
    numbers sum to 1, i.e., normalize the input numbers.
    @return a normalized list of numbers'''
    ### YOUR CODE HERE ###
    total = 0
    for num in nums:
        total += num

    if total == 0:
        return [0] * len(nums)

    normalized = []
    for num in nums:
        normalized.append(num / total)
    return normalized


def min_fill_ordering(Factors, QueryVar):
    '''Factors is a list of factor objects, QueryVar is a query variable.
    Compute an elimination order given list of factors using the min fill heuristic. 
    Variables in the list will be derived from the scopes of the factors in Factors. 
    Order the list such that the first variable in the list generates the smallest
    factor upon elimination. The QueryVar must NOT part of the returned ordering list.
    @return a list of variables''' 
    ### YOUR CODE HERE ###
    '''
    return the order in whcih you will be elimating the variables in make sure the QueryVar is at the end of the list
    
    walk through the different variables and ask what is the size of the factor i am going to create if I eliminate this 
    
    then order these variables in factors size from smallest to greatest 
    ^ eliminate next the variable that creates the smallest size factor 
    
    With min fill the question is really which, or the variables that have yet to be created, will create the smallest 
    factor upon elimination? 
    
    This will involve looking at the size of the various families that the variable 
    you want to delete is a member of. Put the size of all those families together and subtract the eliminated 
    variable and presto ... that is the size of the factor you will generate.
    '''
    scopes = [list(f.get_scope()) for f in Factors]
    variables = set()
    for scope in scopes:
        for var in scope:
            if var != QueryVar:
                variables.add(var)

    min_var_order = []

    while len(variables) > 0:
        var, new_scope = smallest_factor(scopes, variables)

        min_var_order.append(var)
        variables.discard(var)

    return min_var_order


def smallest_factor(scopes, variables):
    """
    function for returning the variable that has the smallest factor
    """
    min_var = None
    min_scope = None
    min_fill = float('inf')

    for var in variables:
        union = set()
        for scope in scopes:
            if var in scope:
                for v in scope:
                    if v != var:
                        union.add(v)

        fill = len(union)

        # set the length of the variable with the smallest factor
        if fill < min_fill:
            min_var = var
            min_scope = union
            min_fill = fill

    return min_var, min_scope


def VE(Net, QueryVar, EvidenceVars):
    """
    Input: Net---a BN object (a Bayes Net)
           QueryVar---a Variable object (the variable whose distribution
                      we want to compute)
           EvidenceVars---a LIST of Variable objects. Each of these
                          variables has had its evidence set to a particular
                          value from its domain using set_evidence.
     VE returns a distribution over the values of QueryVar, i.e., a list
     of numbers, one for every value in QueryVar's domain. These numbers
     sum to one, and the i'th number is the probability that QueryVar is
     equal to its i'th value given the setting of the evidence
     variables. For example if QueryVar = A with Dom[A] = ['a', 'b',
     'c'], EvidenceVars = [B, C], and we have previously called
     B.set_evidence(1) and C.set_evidence('c'), then VE would return a
     list of three numbers. E.g. [0.5, 0.24, 0.26]. These numbers would
     mean that Pr(A='a'|B=1, C='c') = 0.5 Pr(A='a'|B=1, C='c') = 0.24
     Pr(A='a'|B=1, C='c') = 0.26
     @return a list of probabilities, one for each item in the domain of the QueryVar
     """

    '''
    They might ask what is the probability of some queryvariable Q given some evidence e 
    P(Q|e) 
    
    each bayes net comes with a CPT one CPT at each variable 
    
    if I want a probability distribution of the entire joint I can just multiply everything together (the CPTs for each variable)
    
    if I am given evidence I need to restrict the input factors - means u can throw values that is not assigned to the 
    evidence variable in the garbage 
    ^ can just assign the value of a to the evidence variable value and throw everything else out (now reduce the 
    number of variables that needs to be assigned)
    
    step number 2 process of elimination (multiplying and marginalizing) - every variable that is eliminated is going
    to get marginalized away 
    
    always put the query variable at the end at then end you want a distribution over the variable 
    ^ these elimination is put into some ordering 
    
    organize a list of factors in order of elimination - make a list of all the factors that have C in them 
    
    take note of all the factors that have that variable in them from the ordering 
    
    order doesn't matter in terms of the final result just need the queryVariable at the end 
    
    pull out all of the factors in that variables bucket and then multiply them all together 
    and then sum over c and from that you are going to create another factor 
    ^ a table of all the possible values u can assign to the remaining values 
    
    put the factor that you have just created back into a bucket with some variable 
    ^ after you clear the variable you are going to drop the whole bin (bucket) into the trash 
    
    we get some factor - its some number and some numbers associated with the queryVar being true and false 
    
    Last step: normalize 
    
    Make sure all of the entries sum to 1 
    P(D) => P(d) = f11(d)/ f11(d) + f11(not d)
    
    This will the be distribution you would want 
    '''
    # restriction step
    new_factors = []
    evidence_vars = set(EvidenceVars)

    for factor in Net.factors():
        restricted_factor = factor
        scope_vars = set(factor.get_scope())
        common_vars = scope_vars.intersection(evidence_vars)

        if common_vars:
            for var in common_vars:
                restricted_factor = restrict_factor(restricted_factor, var, var.get_evidence())

        new_factors.append(restricted_factor)

    min_fill_order = min_fill_ordering(new_factors, QueryVar)

    for variable in min_fill_order:
        list_of_factors = [factor for factor in new_factors if variable in factor.get_scope()]

        if len(list_of_factors) > 0:
            multiplied_factors = multiply_factors(list_of_factors)
            sum_out_var = sum_out_variable(multiplied_factors, variable)

            # add the factors to the next iteration of the bucket
            bucket = []
            for factor in new_factors:
                if factor not in list_of_factors:
                    bucket.append(factor)

            # include the summed_out variable and update the original list of factors
            bucket.append(sum_out_var)
            new_factors = bucket

    remaining_factors = multiply_factors(new_factors)

    norm = normalize(remaining_factors.values)
    if len(norm) == 0:
        return len(remaining_factors.values) * [float('inf')]

    return norm


def NaiveBayesModel():
    '''
   NaiveBayesModel returns a BN that is a Naive Bayes model that 
   represents the joint distribution of value assignments to 
   variables in the Adult Dataset from UCI.  Remember a Naive Bayes model
   assumes P(X1, X2,.... XN, Class) can be represented as 
   P(X1|Class)*P(X2|Class)* .... *P(XN|Class)*P(Class).
   When you generated your Bayes Net, assume that the values 
   in the SALARY column of the dataset are the CLASS that we want to predict.
   @return a BN that is a Naive Bayes model and which represents the Adult Dataset. 
    '''
    ### READ IN THE DATA
    input_data = []
    with open('data/adult-dataset.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None) #skip header row
        for row in reader:
            input_data.append(row)

    ### DOMAIN INFORMATION REFLECTS ORDER OF COLUMNS IN THE DATA SET
    variable_domains = {
    "Work": ['Not Working', 'Government', 'Private', 'Self-emp'],
    "Education": ['<Gr12', 'HS-Graduate', 'Associate', 'Professional', 'Bachelors', 'Masters', 'Doctorate'],    
    "Occupation": ['Admin', 'Military', 'Manual Labour', 'Office Labour', 'Service', 'Professional'],    
    "MaritalStatus": ['Not-Married', 'Married', 'Separated', 'Widowed'],
    "Relationship": ['Wife', 'Own-child', 'Husband', 'Not-in-family', 'Other-relative', 'Unmarried'],
    "Race": ['White', 'Black', 'Asian-Pac-Islander', 'Amer-Indian-Eskimo', 'Other'],
    "Gender": ['Male', 'Female'],
    "Country": ['North-America', 'South-America', 'Europe', 'Asia', 'Middle-East', 'Carribean'],
    "Salary": ['<50K', '>=50K']
    }

    ### YOUR CODE HERE ###
    variables = []
    for key, value in variable_domains.items():
        variables.append(Variable(key, value))


    # grab how many ppl in the dataset given a specific role makes how much
    work_dataset = getDataSet(input_data, 0)
    education_dataset = getDataSet(input_data, 1)
    occupation_dataset = getDataSet(input_data, 3)
    maritalStatus_dataset = getDataSet(input_data, 2)
    relationship_dataset = getDataSet(input_data, 4)
    race_dataset = getDataSet(input_data, 5)
    gender_dataset = getDataSet(input_data, 6)
    country_dataset = getDataSet(input_data, 7)
    salary_dataset = {}
    for item in input_data:
        if item[-1] in salary_dataset:
            salary_dataset[item[-1]] += 1
        else:
            salary_dataset[item[-1]] = 0

    # perform the total calculations for salary
    salary_total = salary_dataset['<50K'] + salary_dataset['>=50K']
    Fsalary = Factor('P(S)', [variables[-1]])
    Fsalary.add_values(
        [['<50K', salary_dataset['<50K'] / salary_total], ['>=50K', salary_dataset['>=50K'] / salary_total]])

    # From here onwards index 0 is <50k and index 1 is >= 50k
    # perform the total calculations for work
    work_data = getPercentage(work_dataset)
    Fwork = Factor('P(W|S)', [variables[0], variables[-1]])
    work_values = create_add_values(work_data)
    Fwork.add_values(work_values)

    # perform the total calculations for education
    education_data = getPercentage(education_dataset)
    Feducation = Factor('P(E|S)', [variables[1], variables[-1]])
    education_values = create_add_values(education_data)
    Feducation.add_values(education_values)

    # perform the total calculations for occupation
    occupation_data = getPercentage(occupation_dataset)
    Foccupation = Factor('P(O|S)', [variables[2], variables[-1]])
    occupation_values = create_add_values(occupation_data)
    Foccupation.add_values(occupation_values)

    # perform the total calculations for maritalStatus
    maritalStatus_data = getPercentage(maritalStatus_dataset)
    FmaritalStatus = Factor('P(M|S)', [variables[3], variables[-1]])
    maritalStatus_values = create_add_values(maritalStatus_data)
    FmaritalStatus.add_values(maritalStatus_values)

    # perform the total calculations for relationship
    relationship_data = getPercentage(relationship_dataset)
    Frelationship = Factor('P(RE|S)', [variables[4], variables[-1]])
    relationship_values = create_add_values(relationship_data)
    Frelationship.add_values(relationship_values)

    # perform the total calculations for race
    race_data = getPercentage(race_dataset)
    Frace = Factor('P(RA|S)', [variables[5], variables[-1]])
    race_values = create_add_values(race_data)
    Frace.add_values(race_values)

    # perform the total calculations for gender
    gender_data = getPercentage(gender_dataset)
    Fgender = Factor('P(G|S)', [variables[6], variables[-1]])
    gender_values = create_add_values(gender_data)
    Fgender.add_values(gender_values)

    # perform the total calculations for country
    country_data = getPercentage(country_dataset)
    Fcountry = Factor('P(C|S)', [variables[7], variables[-1]])
    country_values = create_add_values(country_data)
    Fcountry.add_values(country_values)

    factors = [Fwork, Feducation, Foccupation, FmaritalStatus, Frelationship, Frace, Fgender, Fcountry, Fsalary]
    name = "NaiveBayesModel of Adult Dataset from UCI"
    bayes_net = BN(name, variables, factors)
    return bayes_net


def create_add_values(percentage_data):
    lst = []
    for data in percentage_data:
        lst.append([data[0], '<50K', data[1]])
        lst.append([data[0], '>=50K', data[2]])
    return lst


def getPercentage(dataset):
    lst = []
    for key, value in dataset.items():
        total = value[0] + value[1]
        lst.append([key, value[0] / total, value[1] / total])

    return lst


def getDataSet(data, index):
    # in the list [] index 0 is <50k and index 1 is >= 50k
    dataset = {}
    for item in data:
        if item[index] in dataset:
            if item[-1] == '<50K':
                dataset[item[index]][0] += 1
            else:
                dataset[item[index]][1] += 1
        else:
            dataset[item[index]] = [0, 0]

    return dataset


def explore(Net, question):
    '''    Input: Net---a BN object (a Bayes Net)
           question---an integer indicating the question in HW4 to be calculated. Options are:
           1. What percentage of the women in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           2. What percentage of the men in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           3. What percentage of the women in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           4. What percentage of the men in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           5. What percentage of the women in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           6. What percentage of the men in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           @return a percentage (between 0 and 100)
    ''' 
    ### YOUR CODE HERE ###

    '''
    In the test set, you'll take information in some columns and use them to predict the values of other columns. 
    So, take values for [Work, Occupation, Education, and Relationship Status] and use them to infer [Salary]. 
    You can then compare your inferences (or predictions) with the "ground truth" in the test file.
    
    For both E1 and E2, you would use the values assigned to the variables for each example in the test set
    '''

    ### DOMAIN INFORMATION REFLECTS ORDER OF COLUMNS IN THE DATA SET
    variable_domains = {
        "Work": ['Not Working', 'Government', 'Private', 'Self-emp'],
        "Education": ['<Gr12', 'HS-Graduate', 'Associate', 'Professional', 'Bachelors', 'Masters', 'Doctorate'],
        "MaritalStatus": ['Not-Married', 'Married', 'Separated', 'Widowed'],
        "Occupation": ['Admin', 'Military', 'Manual Labour', 'Office Labour', 'Service', 'Professional'],
        "Relationship": ['Wife', 'Own-child', 'Husband', 'Not-in-family', 'Other-relative', 'Unmarried'],
        "Race": ['White', 'Black', 'Asian-Pac-Islander', 'Amer-Indian-Eskimo', 'Other'],
        "Gender": ['Male', 'Female'],
        "Country": ['North-America', 'South-America', 'Europe', 'Asia', 'Middle-East', 'Carribean'],
        "Salary": ['<50K', '>=50K']
    }

    # call VE by giving it a set of queryVar and EvidenceVar and pass in the bayes net we created