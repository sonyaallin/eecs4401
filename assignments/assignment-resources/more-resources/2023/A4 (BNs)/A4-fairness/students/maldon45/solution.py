from bnetbase import Variable, Factor, BN
import csv
import itertools


def get_multiply_factors(curr_factor, new_factor):
    # Set curr_factor scope & domain
    curr_factor_scope = curr_factor.get_scope().copy()
    curr_factor_domain = []
    for variable in curr_factor_scope:
        curr_factor_domain.extend(variable.domain())

    # Set new_factor scope & domain
    new_factor_scope = new_factor.get_scope().copy()
    new_factor_domain = []
    for variable in new_factor_scope:
        new_factor_domain.extend(variable.domain())

    # The combination of the factor scopes where each variable is unique
    factors_combined_scope = list(set(curr_factor_scope + new_factor_scope))

    # Get the domain fof each of the unique variables in curr_factor and new_factor
    combined_domain = []
    for variable in factors_combined_scope:
        combined_domain.append(variable.domain())

    # list of tuple combos
    possible_vals = list(itertools.product(*combined_domain))
    # put it in the correct format: list of lists of values
    possible_vals = list(map(list, possible_vals))

    final_values = []

    for curr_value_list in possible_vals:
        curr_factor_variables = []
        new_factor_variables = []

        for variable in curr_value_list:
            if variable in curr_factor_domain:
                curr_factor_variables.append(variable)

            if variable in new_factor_domain:
                new_factor_variables.append(variable)

        curr_factor_vars_updated = []
        new_factor_vars_updated = []

        for variable in curr_factor_scope:
            curr_var_domain = variable.domain()
            for curr_var in curr_factor_variables:
                if curr_var in curr_var_domain:
                    curr_factor_vars_updated.append(curr_var)

        for variable in new_factor_scope:
            new_var_domain = variable.domain()
            for new_var in new_factor_variables:
                if new_var in new_var_domain:
                    new_factor_vars_updated.append(new_var)

        curr_updated_factor_values = curr_factor.get_value(
            curr_factor_vars_updated)
        new_updated_factor_values = new_factor.get_value(
            new_factor_vars_updated)
        updated_factor_values_product = curr_updated_factor_values * new_updated_factor_values
        final_values.append([*curr_value_list ,  updated_factor_values_product])

    # Create the new factor product and assign values!!!
    new_factor_product = Factor(
        "factor_product_of" + curr_factor.name + " &" + new_factor.name, factors_combined_scope)
    new_factor_product.add_values(final_values)

    return new_factor_product


def multiply_factors(Factors):
    '''Factors is a list of factor objects.
    Return a new factor that is the product of the factors in Factors.
    @return a factor'''

    first_factor = Factors[0]
    first_factor_values = Factors[0].values.copy()
    remaining_factors = Factors[1:]

    new_factor = Factor(first_factor.name, first_factor.get_scope())
    new_factor.values = first_factor_values

    for curr_factor in remaining_factors:
        new_factor = get_multiply_factors(curr_factor, new_factor)

    return new_factor


def restrict_factor(f, var, value):
    '''f is a factor, var is a Variable, and value is a value from var.domain.
    Return a new factor that is the restriction of f by this var = value.
    Don't change f! If f has only one variable its restriction yields a
    constant factor.
    @return a factor'''
    f_scope = f.get_scope()  # more efficient calculation
    # create the new factor
    new_factor = Factor("f_restricted_over_" + str(var.name), f_scope)

    # update the function's scope to remove var
    var_domains = []
    for curr_var in f_scope:
        var_domains.append(curr_var.domain())

    possible_vals = list(itertools.product(*var_domains))  # list of tuple combos
    # put it in the correct format: list of lists
    possible_vals = list(map(list, possible_vals))

    new_factor_values = []

    for curr_value_list in possible_vals:
        if value in curr_value_list:
            factor_value = f.get_value(curr_value_list)
            new_factor_values.append([*curr_value_list, factor_value])

    new_factor.add_values(new_factor_values)
    return new_factor


def sum_out_variable(f, var):
    '''f is a factor, var is a Variable.
    Return a new factor that is the result of summing var out of f, by summing
    the function generated by the product over all values of var.
    @return a factor'''

    f_scope = f.get_scope()  # more efficient calculation
    # create the new factor
    new_factor = Factor("f_marginalized_over_" + str(var.name), f_scope)
    new_factor.scope.remove(var)

    # update the function's scope to remove var
    scope_no_vars = []
    for curr_var in f_scope:
        if not (curr_var == var):
            scope_no_vars.append(curr_var.domain())

    # list of tuple combos
    possible_vals = list(itertools.product(*scope_no_vars))
    # put it in the correct format: list of lists
    possible_vals = list(map(list, possible_vals))

    var_position = f_scope.index(var)
    new_factor_values = []

    for curr_value_list in possible_vals:
        value_sum = 0
        var_domain = var.domain()  # more efficient calculation
        for sub_value in var_domain:
            actual_value = curr_value_list[:var_position] + [sub_value] + curr_value_list[var_position:]
            value_sum += f.get_value(actual_value)
        new_factor_values.append(curr_value_list + [value_sum])

    new_factor.add_values(new_factor_values)
    return new_factor


def normalize(nums):
    '''num is a list of numbers. Return a new list of numbers where the new
    numbers sum to 1, i.e., normalize the input numbers.
    @return a normalized list of numbers'''
    normalized = []
    nums_total = 0
    for num in nums:
        nums_total += abs(num)

    if nums_total == 0:
        return [1/len(nums)] * (len(nums))
    else:
        for num in nums:
            normalized.append(abs(num)/nums_total)
        return normalized


def min_fill_ordering(Factors, QueryVar):
    '''Factors is a list of factor objects, QueryVar is a query variable.
    Compute an elimination order given list of factors using the min fill heuristic.
    Variables in the list will be derived from the scopes of the factors in Factors.
    Order the list such that the first variable in the list generates the smallest
    factor upon elimination. The QueryVar must NOT part of the returned ordering list.
    @return a list of variables'''

    derived_variables = []
    tracked_variables = []

    for curr_factor in Factors:
        for variable in curr_factor.get_scope():
            if variable != QueryVar and variable not in tracked_variables:
                tracked_variables.append(variable)
                appearances = 0
                for var_factor in Factors:
                    if variable in var_factor.get_scope():
                        appearances += 1
                derived_variables.append([variable, appearances])

    # sort the variables from least to most appearances
    derived_variables.sort(key=lambda y: y[1])
    mf_ordered_vars = []

    for curr_variable in derived_variables:
        mf_ordered_vars.append(curr_variable[0])  # just include the variables

    return mf_ordered_vars


def VE(Net, QueryVar, EvidenceVars):
    """
    Input: Net---a BN object (a Bayes Net)
           QueryVar---a Variable object (the variable whose distribution
                      we want to compute)
           EvidenceVars---a LIST of Variable objects. Each of these
                          variables has had its evidence set to a particular
                          value from its domain using set_evidence.
     VE returns a distribution over the values of QueryVar, i.e., a list
     of numbers, one for every value in QueryVar's domain. These numbers
     sum to one, and the i'th number is the probability that QueryVar is
     equal to its i'th value given the setting of the evidence
     variables. For example if QueryVar = A with Dom[A] = ['a', 'b',
     'c'], EvidenceVars = [B, C], and we have previously called
     B.set_evidence(1) and C.set_evidence('c'), then VE would return a
     list of three numbers. E.g. [0.5, 0.24, 0.26]. These numbers would
     mean that Pr(A='a'|B=1, C='c') = 0.5 Pr(A='a'|B=1, C='c') = 0.24
     Pr(A='a'|B=1, C='c') = 0.26
     @return a list of probabilities, one for each item in the domain of the QueryVar
     """
    network_factors = Net.factors()
    # Replace each factor that mentions a variable in the evidence with the restriction on the factor
    for factor_position in range(len(network_factors)):
        curr_factor = network_factors[factor_position]
        for evidence_var in EvidenceVars:
            if evidence_var in curr_factor.get_scope():
                network_factors[factor_position] = restrict_factor(curr_factor, evidence_var, evidence_var.get_evidence())

    # Order the updated network factors
    mf_ordered_vars = min_fill_ordering(network_factors, QueryVar)

    # Computing the new factors where each factor includes the other factor z_j (from notes)
    for curr_variable in mf_ordered_vars:
        factors_in_scope = []
        for curr_factor in network_factors:
            if curr_variable in curr_factor.get_scope():
                factors_in_scope.append(curr_factor)
        # Remove the factors that include z_j (the old factors)
        # So that the remaining factors only refer to QueryVar
        network_factors = [curr_factor for curr_factor in network_factors if curr_factor not in factors_in_scope]

        # Now I need to take the product of the factors that refer only to QueryVar
        factor_product = multiply_factors(factors_in_scope)
        # Adding the new factor to the main factors
        new_factor = sum_out_variable(factor_product, curr_variable)
        network_factors.append(new_factor)

    final_product = multiply_factors(network_factors)
    # Now the product of the factors needs to be normalized
    # So that it's a probability distribution that sums up to 1.
    return normalize(final_product.values)


def NaiveBayesModel():
    '''
   NaiveBayesModel returns a BN that is a Naive Bayes model that
   represents the joint distribution of value assignments to
   variables in the Adult Dataset from UCI.  Remember a Naive Bayes model
   assumes P(X1, X2,.... XN, Class) can be represented as
   P(X1|Class)*P(X2|Class)* .... *P(XN|Class)*P(Class).
   When you generated your Bayes Net, assume that the values
   in the SALARY column of the dataset are the CLASS that we want to predict.
   @return a BN that is a Naive Bayes model and which represents the Adult Dataset.
    '''
    # READ IN THE DATA
    input_data = []
    with open('data/adult-dataset.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None)  # skip header row
        for row in reader:
            input_data.append(row)

    # DOMAIN INFORMATION REFLECTS ORDER OF COLUMNS IN THE DATA SET
    variable_domains = {
        "Work": ['Not Working', 'Government', 'Private', 'Self-emp'],
        "Education": ['<Gr12', 'HS-Graduate', 'Associate', 'Professional', 'Bachelors', 'Masters', 'Doctorate'],
        "Occupation": ['Admin', 'Military', 'Manual Labour', 'Office Labour', 'Service', 'Professional'],
        "MaritalStatus": ['Not-Married', 'Married', 'Separated', 'Widowed'],
        "Relationship": ['Wife', 'Own-child', 'Husband', 'Not-in-family', 'Other-relative', 'Unmarried'],
        "Race": ['White', 'Black', 'Asian-Pac-Islander', 'Amer-Indian-Eskimo', 'Other'],
        "Gender": ['Male', 'Female'],
        "Country": ['North-America', 'South-America', 'Europe', 'Asia', 'Middle-East', 'Carribean'],
        "Salary": ['<50K', '>=50K']
    }
    ### MY CODE :) ###

    # CREATE THE VARIABLES ... (Turn the vars in variable_domain into actual objects)
    BN_variables = []
    all_variables = variable_domains.keys()
    for curr_variable in all_variables:
        BN_variables.append(Variable(curr_variable,variable_domains[curr_variable]))


    # CREATE THE FACTORS
    # Since we can assume P(X1|Class)*P(X2|Class)* .... *P(XN|Class)*P(Class)
    # and the class is SALARY then I need to get the number of people (represented by each row)
    # in the dataset who have a salary of <50K and those that have a salary >=50K
    salary = {'<50K':0, '>=50K':0}

    for curr_row in input_data:
        salary_col = curr_row[8]
        if salary_col in salary:
            salary[salary_col] += 1

    BN_factors = []
    # Work --------------------------
    work_given_salary = Factor('P(work|salary)', [BN_variables[0], BN_variables[8]])
    work_given_salary.add_values(get_given_domain(variable_domains["Work"], variable_domains["Salary"], input_data, 8, 0, salary))
    BN_factors.append(work_given_salary)
    # Education ---------------------
    education_given_salary = Factor('P(education|salary)', [BN_variables[1], BN_variables[8]])
    education_given_salary.add_values(get_given_domain(variable_domains['Education'], variable_domains['Salary'], input_data, 8, 1, salary))
    BN_factors.append(education_given_salary)
    # Occupation --------------------
    occupation_given_salary = Factor('P(occupation|salary)', [BN_variables[2], BN_variables[8]])
    occupation_given_salary.add_values(get_given_domain(variable_domains['Occupation'], variable_domains['Salary'], input_data, 8, 3, salary)) # column 3 in data but second var in BN_variables
    BN_factors.append(occupation_given_salary)
    # MaritalStatus -----------------
    maritalStatus_given_salary = Factor('P(maritalStatus|salary)', [BN_variables[3], BN_variables[8]])
    maritalStatus_given_salary.add_values(get_given_domain(variable_domains['MaritalStatus'], variable_domains['Salary'], input_data, 8, 2, salary)) # column 2 in data but third var in BN_variables
    BN_factors.append(maritalStatus_given_salary)
    # Relationship ------------------
    relationship_given_salary = Factor('P(relationship|salary)', [BN_variables[4], BN_variables[8]])
    relationship_given_salary.add_values(get_given_domain(variable_domains['Relationship'], variable_domains['Salary'], input_data, 8, 4, salary))
    BN_factors.append(relationship_given_salary)
    # Race --------------------------
    race_given_salary = Factor('P(race|salary)', [BN_variables[5], BN_variables[8]])
    race_given_salary.add_values(get_given_domain(variable_domains['Race'], variable_domains['Salary'], input_data, 8, 5, salary))
    BN_factors.append(race_given_salary)
    # Gender ------------------------
    gender_given_salary = Factor('P(gender|salary)', [BN_variables[6], BN_variables[8]])
    gender_given_salary.add_values(get_given_domain(variable_domains['Gender'], variable_domains['Salary'], input_data, 8, 6, salary))
    BN_factors.append(gender_given_salary)
    # Country -----------------------
    country_given_salary = Factor('P(country|salary)', [BN_variables[7], BN_variables[8]])
    country_given_salary.add_values(get_given_domain(variable_domains['Country'], variable_domains['Salary'], input_data, 8, 7, salary))
    BN_factors.append(country_given_salary)

    # Salary ------------------------ P(salary)
    data_entries = len(input_data)
    p_of_salary = Factor('P(salary)', [BN_variables[8]])
    p_of_salary.add_values([['<50K', salary['<50K']/data_entries], ['>=50K', salary['>=50K']/data_entries]])
    BN_factors.append(p_of_salary)

    # Finally return the BN !!!
    return BN("adult data set BN", BN_variables, BN_factors)

def get_given_domain(variable_domain, salary_domain, input_data, salary_index, var_index, salary):
    # list of tuple combos
    possible_vals = list(itertools.product(variable_domain, salary_domain))
    # put it in the correct format: list of lists of values
    possible_vals = list(map(list, possible_vals))

    for curr_value_list in possible_vals:
        curr_value_list.append(0) # counter

    for curr_row in input_data:
        for curr_value_list in possible_vals:
            if curr_value_list[0] == curr_row[var_index] and curr_value_list[1] == curr_row[salary_index]:
                curr_value_list[2] += 1 # update the counter

    for curr_value_list in possible_vals:
        # update the final counter to the actual value needed:
        # (the count of people with specific category and salary) / The total number of people with that salary
        curr_value_list[2] = curr_value_list[2]/salary[curr_value_list[1]]

    return possible_vals


# TO CREATE CORE EVIDENCE SETS DURING EXPLORATION :)
def get_evidence_sets(Net, curr_row):
    evidence_set_1 = []
    evidence_set_2 = []

    work = Net.get_variable("Work")
    work.set_evidence(curr_row[0])
    evidence_set_1.append(work)
    evidence_set_2.append(work)

    occupation = Net.get_variable("Occupation")
    occupation.set_evidence(curr_row[3])
    evidence_set_1.append(occupation)
    evidence_set_2.append(occupation)

    education = Net.get_variable("Education")
    education.set_evidence(curr_row[1])
    evidence_set_1.append(education )
    evidence_set_2.append(education )

    relationship = Net.get_variable("Relationship")
    relationship.set_evidence(curr_row[4])
    evidence_set_1.append(relationship)
    evidence_set_2.append(relationship)

    # evidence set 1 does not have the gender, but evidence 2 has the gender
    gender = Net.get_variable("Gender")
    gender.set_evidence(curr_row[6])
    evidence_set_2.append(gender)

    return evidence_set_1, evidence_set_2


def Explore(Net, question):
    '''    Input: Net---a BN object (a Bayes Net)
           question---an integer indicating the question in HW4 to be calculated. Options are:
           1. What percentage of the women in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           2. What percentage of the men in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           3. What percentage of the women in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           4. What percentage of the men in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           5. What percentage of the women in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           6. What percentage of the men in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           @return a percentage (between 0 and 100)
    '''
    ### READ IN THE DATA
    input_data = []
    with open('data/test-data.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None) #skip header row
        for row in reader:
            input_data.append(row)

    ### MY CODE :) ###

    occurrences = 0
    total = 0
    for curr_row in input_data:
        # To make the code cleaner I will have a dictionary with the question keys and conditions of the question as values
        Questions = {1:[curr_row[6] == 'Female'], 2:[curr_row[6] == 'Male'], 3:[curr_row[6] == 'Female'],  4:[curr_row[6] == 'Male'], 5:[curr_row[6] == 'Female'], 6:[curr_row[6] == 'Male']}
        # evidence set 1 does not have the gender, but evidence 2 has the gender
        if Questions[question][0]:
            QueryVar = Net.get_variable("Salary")
            evidence_set_1, evidence_set_2 = get_evidence_sets(Net, curr_row)
            p_1 = VE(Net, QueryVar, evidence_set_1)

            if (question == 1 or question == 2):
                total += 1
                p_2 = VE(Net, QueryVar, evidence_set_2)
                if p_1[1] > p_2[1]:
                    occurrences += 1

            elif (question == 3 or question == 4):
                if p_1[1] > 0.5:
                    total += 1
                    if curr_row[8] == '>=50K':
                        occurrences += 1

            elif (question == 5 or question == 6):
                total += 1
                if p_1[1] > 0.5:
                    occurrences += 1

    return occurrences/total * 100

