from bnetbase import Variable, Factor, BN
import csv
import itertools as it
import numpy as np

def multiply_factors(Factors):
    '''Factors is a list of factor objects.
    Return a new factor that is the product of the factors in Factors.
    @return a factor''' 
    ### YOUR CODE HERE ###
    # Get all variables (in order)
    ordered_variables = list({v for f in Factors for v in f.get_scope()})
    # Get list of list of domains i.e [['a', 'b'], ['yes', 'no']]
    domains = [v.domain() for v in ordered_variables]
    # Get all possible assignments i.e [['a', 'yes'], ['a', 'no'], ...] in variable order.
    assignments = [list(s) for s in it.product(*domains)]
    # Use helper to return list of assingments and corresponding probablities
    vals = [mult_f_helper(Factors, ordered_variables, asn) for asn in assignments]
    # Make name
    name = 'f(' + ''.join(f'{v.name}' for v in ordered_variables) + ')'
    
    # Make factor
    factor = Factor(name, ordered_variables)
    factor.add_values(vals)
    return factor
    
    
def mult_f_helper(Factors, variables, assignment):
    # Assign <assignment> to variables
    _ = [variables[i].set_assignment(assignment[i]) for i in range(len(assignment))]
    # Get probabilities for current assignment
    vals = [f.get_value_at_current_assignments() for f in Factors]
    assignment.append(np.prod(vals))
    return assignment
    
    


def restrict_factor(f, var, value):
    '''f is a factor, var is a Variable, and value is a value from var.domain.
    Return a new factor that is the restriction of f by this var = value.
    Don't change f! If f has only one variable its restriction yields a
    constant factor.
    @return a factor''' 
    ### YOUR CODE HERE ###
    # Get scope
    f_scope = f.get_scope()
    
    if len(f_scope) == 1:
        var_prob = f.get_value([value])
        vals = [[value, var_prob]]
        name = 'f(' + var.name + ' = ' + str(value) + ')'
        new_scope = []
        
    else:
        # List of domains, set restricted variable to size 1 with assigned value
        domains = [[value] if v == var else v.domain() for v in f_scope]
        # Gerenate possible assignments
        assignments = [list(s) for s in it.product(*domains)]
        # Get probablities of each assignment
        probs = [f.get_value(a) for a in assignments]
        # For each assignment, remove restricted element, add corresponding probablity
        vals = [[val for val in assignments[i] if val != value] + [probs[i]] for i in range(len(assignments))]
        # New scope without new assignment
        new_scope = [v for v in f_scope if v != var]

        name = 'f(' + ''.join(f'{v.name}' for v in new_scope) + ')'
    
    factor = Factor(name, new_scope)
    factor.add_values(vals)
    return factor


def sum_out_variable(f, var):
    '''f is a factor, var is a Variable.
    Return a new factor that is the result of summing var out of f, by summing
    the function generated by the product over all values of var.
    @return a factor'''       
    ### YOUR CODE HERE ###
    # Get scope
    f_scope = f.get_scope()
    var_ind = f_scope.index(var)
    # List of domains, set restricted variable to size 1 with assigned value
    domains = [v.domain() for v in f_scope]
    # Gerenate possible assignments
    assignments = [list(s) for s in it.product(*domains)]
    # Get probablities of each assignment
    probs = [f.get_value(a) for a in assignments]
    # Instance assgnment dictionary
    asgn_dict = {}
    # Remove assignment for <var> for each assignment list
    cleaned_asgn = [[assignments[i][j] for j in range(len(f_scope)) if j != var_ind] for i in range(len(assignments))]
    # Make str keys for dictionary
    asgn_str = [','.join(asgn) for asgn in cleaned_asgn]
    
    # Store assignments in dictionaries, add probablity if same assignment is found
    _ = [sum_out_helper(asgn_dict, asgn_str[i], probs[i]) if asgn_str[i] in asgn_dict else asgn_dict.setdefault(asgn_str[i], cleaned_asgn[i] + [probs[i]]) for i in range(len(cleaned_asgn))]
    # Get values of dict, they are complete value lists
    vals = asgn_dict.values()
    new_scope = [v for v in f_scope if v != var]
    
    name = 'f(' + ''.join(f'{v.name}' for v in new_scope) + ')'
    
    factor = Factor(name, new_scope)
    factor.add_values(vals)
    
    return factor
    
    
def sum_out_helper(dict, key, add):
    # Add probablity to our list
    new_lst = dict[key][:-1] + [dict[key][-1] + add]
    dict[key] = new_lst


def normalize(nums):
    '''num is a list of numbers. Return a new list of numbers where the new
    numbers sum to 1, i.e., normalize the input numbers.
    @return a normalized list of numbers'''
    ### YOUR CODE HERE ###
    if not np.any(nums):
        tot = len(nums)
        return [1/tot] * tot
    else:
        tot = sum(nums)
        return [num/tot for num in nums]


def min_fill_ordering(Factors, QueryVar):
    '''Factors is a list of factor objects, QueryVar is a query variable.
    Compute an elimination order given list of factors using the min fill heuristic. 
    Variables in the list will be derived from the scopes of the factors in Factors. 
    Order the list such that the first variable in the list generates the smallest
    factor upon elimination. The QueryVar must NOT part of the returned ordering list.
    @return a list of variables''' 
    ### YOUR CODE HERE ###
    non_query_var = list({v for f in Factors for v in f.get_scope() if v != QueryVar})
    return sorted(non_query_var, key=lambda var: calc_res_factor(var, Factors))
    
    
    
def calc_res_factor(var, Factors):
    # Look at all factors with variable in scope, their total is the resulting factor total.
    filtered_var = {v for f in Factors if var in f.get_scope() for v in f.get_scope() if v != var}
    return len(filtered_var)
    
    
    


def VE(Net, QueryVar, EvidenceVars):
    
    """
    Input: Net---a BN object (a Bayes Net)
           QueryVar---a Variable object (the variable whose distribution
                      we want to compute)
           EvidenceVars---a LIST of Variable objects. Each of these
                          variables has had its evidence set to a particular
                          value from its domain using set_evidence.
     VE returns a distribution over the values of QueryVar, i.e., a list
     of numbers, one for every value in QueryVar's domain. These numbers
     sum to one, and the i'th number is the probability that QueryVar is
     equal to its i'th value given the setting of the evidence
     variables. For example if QueryVar = A with Dom[A] = ['a', 'b',
     'c'], EvidenceVars = [B, C], and we have previously called
     B.set_evidence(1) and C.set_evidence('c'), then VE would return a
     list of three numbers. E.g. [0.5, 0.24, 0.26]. These numbers would
     mean that Pr(A='a'|B=1, C='c') = 0.5 Pr(A='b'|B=1, C='c') = 0.24
     Pr(A='c'|B=1, C='c') = 0.26
     @return a list of probabilities, one for each item in the domain of the QueryVar
     """
    ### YOUR CODE HERE ###
    # get factors of bayes net
    factors = Net.factors()
    # Restrict factors by list of evidence, drop constant factors
    restricted_factors = [temp for f in factors if (temp := multi_restrict(f, EvidenceVars)).get_scope() != []]
    # Get order using minimum fill hueristic
    variable_order = min_fill_ordering(restricted_factors, QueryVar)
    # For rach non-query variable, sum out product of relevant factors and replace factors
    for v in variable_order:
        remaining_factors = []
        relevant_factors = []
        
        # Sort to relevant and non-relevant factors, pertaining to current variable
        _ = [relevant_factors.append(f) if v in f.get_scope() else remaining_factors.append(f) for f in restricted_factors]
        
        # If more that one remaining factor i.e (not done eliminating)
        if len(relevant_factors) > 1: 
            # Get new factor (sum of product)
            new_fact = sum_out_variable(multiply_factors(relevant_factors), v)
            # If new factor not constant
            if new_fact.get_scope() != []:
                restricted_factors = remaining_factors + [new_fact]
        # Other wise, drop constant var, work with remain factors
            else:
                restricted_factors = remaining_factors
        else:
            restricted_factors = remaining_factors
    
    final_factor = restricted_factors[0]
    # Normalize distributions
    distribution = normalize([final_factor.get_value([val]) for val in QueryVar.domain()])
    # print(distribution)
    
    return(distribution)
    
def multi_restrict(factor, evidence):
    # Get scope
    f_scope = factor.get_scope()
    # If out of evidence, or no restrictions needed
    if evidence == [] or evidence[0] not in f_scope:
        return factor
    evid = evidence[0]
    # Otherwise, restrict factor by first evidence
    new_fact = restrict_factor(factor, evid, evid.get_evidence())
    # Test remaining evidence against new factor
    return multi_restrict(new_fact, evidence[1:])



def NaiveBayesModel():
    '''
   NaiveBayesModel returns a BN that is a Naive Bayes model that 
   represents the joint distribution of value assignments to 
   variables in the Adult Dataset from UCI.  Remember a Naive Bayes model
   assumes P(X1, X2,.... XN, Class) can be represented as 
   P(X1|Class)*P(X2|Class)* .... *P(XN|Class)*P(Class).
   When you generated your Bayes Net, assume that the values 
   in the SALARY column of the dataset are the CLASS that we want to predict.
   @return a BN that is a Naive Bayes model and which represents the Adult Dataset. 
    '''
    ### READ IN THE DATA
    input_data = []
    with open('data/adult-dataset.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None) #skip header row
        for row in reader:
            input_data.append(row)

    ### DOMAIN INFORMATION REFLECTS ORDER OF COLUMNS IN THE DATA SET
    variable_domains = {
    "Work": ['Not Working', 'Government', 'Private', 'Self-emp'],
    "Education": ['<Gr12', 'HS-Graduate', 'Associate', 'Professional', 'Bachelors', 'Masters', 'Doctorate'],
    "MaritalStatus": ['Not-Married', 'Married', 'Separated', 'Widowed'],
    "Occupation": ['Admin', 'Military', 'Manual Labour', 'Office Labour', 'Service', 'Professional'],    
    "Relationship": ['Wife', 'Own-child', 'Husband', 'Not-in-family', 'Other-relative', 'Unmarried'],
    "Race": ['White', 'Black', 'Asian-Pac-Islander', 'Amer-Indian-Eskimo', 'Other'],
    "Gender": ['Male', 'Female'],
    "Country": ['North-America', 'South-America', 'Europe', 'Asia', 'Middle-East', 'Carribean'],
    "Salary": ['<50K', '>=50K']
    }
    ### YOUR CODE HERE ###
    np_data = np.array(input_data)
    variables = [Variable(d, variable_domains[d]) for d in variable_domains]
    non_prior_v, prior = variables[:-1], variables[-1]
    greater = np_data[(np_data[:, -1] == '>=50K')].shape[0]
    lesser = np_data[(np_data[:, -1] == '<50K')].shape[0]
    
    factors = [create_naive_factor(non_prior_v[i], i, prior, np_data, lesser, greater) for i in range(len(non_prior_v))]
    
    total = np_data.shape[0]
    prior_vals = [['>=50K', greater/total], ['<50K', lesser/total]]
    prior_name = 'P(Salary)'
    
    prior_factor = Factor(prior_name, [prior])
    prior_factor.add_values(prior_vals)
    factors.append(prior_factor)

    
    # _ = [f.print_table() for f in factors]
    
    return BN('Salary Naive Bayes Model', variables, factors)
    
    
    

def create_naive_factor(v, index, prior, data, less_len, more_len):
    assignments = [list(s) for s in it.product(*[v.domain(), prior.domain()])]
    masks = [(asg[1], (data[:, index] == asg[0]) & (data[:, -1] == asg[1])) for asg in assignments]
    
    probs = [data[mask[1]].shape[0]/more_len if mask[0] == '>=50K' else data[mask[1]].shape[0]/less_len for mask in masks]
    vals = [assignments[i] + [probs[i]] for i in range(len(assignments))]
    name = 'P(' + v.name + '|' + prior.name + ')'
    factor = Factor(name, [v, prior])
    factor.add_values(vals)
    
    return factor


def Explore(Net: BN, question):
    '''
           Input: Net---a BN object (a Bayes Net)
           question---an integer indicating the question in HW4 to be calculated. Options are:
           1. What percentage of the women in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           2. What percentage of the men in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           3. What percentage of the women in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           4. What percentage of the men in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           5. What percentage of the women in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           6. What percentage of the men in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           @return a percentage (between 0 and 100)
    ''' 
    ### YOUR CODE HERE ###
    input_data = []
    with open('data/test-data.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None) #skip header row
        for row in reader:
            input_data.append(row)
    np_data = np.array(input_data)
    
    male_data = np_data[(np_data[:, -3] == 'Male')]
    female_data = np_data[(np_data[:, -3] == 'Female')]
    
    male_total = male_data.shape[0]
    female_total = female_data.shape[0]
            
    variables = Net.variables()
            
    E1 = ['Work', 'Occupation', 'Education', 'Relationship']
    E2 = ['Work', 'Occupation', 'Education', 'Relationship', 'Gender']
    
    Query_var = variables[-1]
    
    E1_ind = [i for i in range(len(variables)) if variables[i].name in E1]
    E2_ind = [i for i in range(len(variables)) if variables[i].name in E2]
    
    E1_vars = [variables[i] for i in E1_ind]
    E2_vars = [variables[i] for i in E2_ind]
    
    E1_male_data = male_data[:, E1_ind]
    E1_female_data = female_data[:, E1_ind]
    E2_male_data = male_data[:, E2_ind]
    E2_female_data = female_data[:, E2_ind]
    
    female_E1_probs = np.apply_along_axis(lambda row: calc_row_prob(Net, Query_var, E1_vars, row), axis=1, arr=E1_female_data)
    female_E2_probs = np.apply_along_axis(lambda row: calc_row_prob(Net, Query_var, E2_vars, row), axis=1, arr=E2_female_data)
    
    male_E1_probs = np.apply_along_axis(lambda row: calc_row_prob(Net, Query_var, E1_vars, row), axis=1, arr=E1_male_data)
    male_E2_probs = np.apply_along_axis(lambda row: calc_row_prob(Net, Query_var, E2_vars, row), axis=1, arr=E2_male_data)
    
    if question == 1:
        return (np.count_nonzero(female_E1_probs[:, 1] > female_E2_probs[:, 1])/female_total) * 100
    elif question == 2:
        return (np.count_nonzero(male_E1_probs[:, 1] > male_E2_probs[:, 1])/male_total) * 100
    elif question == 3:
        return (np.count_nonzero(np.logical_and((female_E1_probs[:, 1] > 0.5), (female_data[:, -1] == '>=50K')))/female_data[(female_data[:, -1] == '>=50K')].shape[0]) * 100
    elif question == 4:
        return (np.count_nonzero(np.logical_and((male_E1_probs[:, 1] > 0.5), (male_data[:, -1] == '>=50K')))/male_data[(male_data[:, -1] == '>=50K')].shape[0]) * 100
    elif question == 5:
        return (np.count_nonzero(female_E1_probs[:, 1] > 0.5)/female_total) * 100
    elif question == 6:
        return (np.count_nonzero(male_E1_probs[:, 1] > 0.5)/male_total) * 100
    
    
def calc_row_prob(Net, Query_var, variables, row):
    _ = [variables[i].set_evidence(row[i]) for i in range(len(row))]
    probs = VE(Net, Query_var, variables)
    return probs
    
    
    

