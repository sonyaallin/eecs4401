from bnetbase import Variable, Factor, BN
import csv
import itertools

def multiply_factors(Factors):
    '''Factors is a list of factor objects.
    Return a new factor that is the product of the factors in Factors.
    @return a factor''' 
    if Factors == []:
        return Factors
    
    if len(Factors) == 1:
        return Factors[0]
    
    new_scope = combine_scope(Factors)
    assignments = itertools.product(*[var.domain() for var in new_scope])

    return factors_product(new_scope, assignments, Factors)       

def combine_scope(Factors):
    '''Returns a list of a union of scopes 
    '''
    scope = set(var for factor in Factors for var in factor.get_scope())
    return list(scope)

def factors_product(scope, assignments, Factors):
    '''Returns a new factor that is a product of the factors in Factors
    '''
    new_factor = Factor('m-factor', scope)
    
    for assignment in assignments:
        var_product = 1
        for var, value in zip(scope, assignment):
            var.set_assignment(value)
        for factor in Factors:
            var_product *= factor.get_value_at_current_assignments()
        new_factor.add_value_at_current_assignment(var_product)
        
    return new_factor
    

def restrict_factor(f, var, value):
    '''f is a factor, var is a Variable, and value is a value from var.domain.
    Return a new factor that is the restriction of f by this var = value.
    Don't change f! If f has only one variable its restriction yields a
    constant factor.
    @return a factor''' 
    scope = f.get_scope()
    var_index = scope.index(var)
    
    # set scope to not include var
    new_scope = [variable for variable in scope if variable != var]
    new_factor = Factor('r-factor', new_scope)
    
    cartesian = itertools.product(*[var.domain() for var in scope])
    values = []
    
    for assignment in cartesian:
        # add assignments that only contain var=value
        if assignment[var_index] == value:
            value_saved = f.get_value(assignment)
            remove_var = list(assignment)
            remove_var.pop(var_index)
            remove_var.append(value_saved)
            values.append(remove_var)
        
    new_factor.add_values(values)
    return new_factor


def sum_out_variable(f, var):
    '''f is a factor, var is a Variable.
    Return a new factor that is the result of summing var out of f, by summing
    the function generated by the product over all values of var.
    @return a factor'''       
    scope = f.get_scope()
    var_index = scope.index(var)
    
    # set scope to not include var
    new_scope = [variable for variable in scope if variable != var]
    new_factor = Factor(f.name + ' ' + var.name, new_scope)
    cartesian = itertools.product(*[var.domain() for var in new_scope])
    values = []
    
    for assignment in cartesian:
        sum = 0
        for v in var.domain():
            temp = list(assignment)
            temp.insert(var_index, v) # insert value from var domain to extract the assignment value
            sum += f.get_value(temp)
        
        values.append(list(assignment) + [sum])

    new_factor.add_values(values)
    return new_factor
    

def normalize(nums):
    '''num is a list of numbers. Return a new list of numbers where the new
    numbers sum to 1, i.e., normalize the input numbers.
    @return a normalized list of numbers'''
    if nums == []:
        return nums
    
    all_zeros = True
    
    for i in nums:
        if i != 0:
            all_zeros = False
            break
    
    if all_zeros: # assign equal probability mass
        set_val = 1/len(nums)
        return [set_val]*len(nums)
        
    return [var/sum(nums) for var in nums] 


def min_fill_ordering(Factors, QueryVar):
    '''Factors is a list of factor objects, QueryVar is a query variable.
    Compute an elimination order given list of factors using the min fill heuristic. 
    Variables in the list will be derived from the scopes of the factors in Factors. 
    Order the list such that the first variable in the list generates the smallest
    factor upon elimination. The QueryVar must NOT part of the returned ordering list.
    @return a list of variables''' 
    scopes = [factor.get_scope() for factor in Factors]
    
    # list containing Variables excluding the query variable
    all_vars = list({var for scope in scopes for var in scope if var != QueryVar})
    
    return all_vars
    

def VE(Net, QueryVar, EvidenceVars):
    
    """
    Input: Net---a BN object (a Bayes Net)
           QueryVar---a Variable object (the variable whose distribution
                      we want to compute)
           EvidenceVars---a LIST of Variable objects. Each of these
                          variables has had its evidence set to a particular
                          value from its domain using set_evidence.
     VE returns a distribution over the values of QueryVar, i.e., a list
     of numbers, one for every value in QueryVar's domain. These numbers
     sum to one, and the i'th number is the probability that QueryVar is
     equal to its i'th value given the setting of the evidence
     variables. For example if QueryVar = A with Dom[A] = ['a', 'b',
     'c'], EvidenceVars = [B, C], and we have previously called
     B.set_evidence(1) and C.set_evidence('c'), then VE would return a
     list of three numbers. E.g. [0.5, 0.24, 0.26]. These numbers would
     mean that Pr(A='a'|B=1, C='c') = 0.5 Pr(A='a'|B=1, C='c') = 0.24
     Pr(A='a'|B=1, C='c') = 0.26
     @return a list of probabilities, one for each item in the domain of the QueryVar
     """
    factors = restrict(Net, EvidenceVars)
    order = min_fill_ordering(factors, QueryVar)
    
    while order:
        selected = order[0] # variable to be eliminated
        common_factors = [] # factors that contain selected variable in scope

        for factor in factors:
            if selected in factor.get_scope():
                common_factors.append(factor)  
                
        multiply_factor = multiply_factors(common_factors)
        sum_factor = sum_out_variable(multiply_factor, selected)
        
        for factor in common_factors:
            factors.remove(factor)
            
        factors.append(sum_factor)
        
        order.pop(0)

    product = multiply_factors(factors)
    return normalize(product.values)
    

def restrict(Net, EvidenceVars):
    """
    Replace each factor in Net that mentions a variable in E with its restriction
    @return a list of factors
    """
    factors = []
    for factor in Net.factors():
        new_factor = factor
        for var in EvidenceVars:
            if var in new_factor.get_scope():
                new_factor = restrict_factor(new_factor, var, var.get_evidence())  
        factors.append(new_factor)
    return factors


def NaiveBayesModel():
    '''
   NaiveBayesModel returns a BN that is a Naive Bayes model that 
   represents the joint distribution of value assignments to 
   variables in the Adult Dataset from UCI.  Remember a Naive Bayes model
   assumes P(X1, X2,.... XN, Class) can be represented as 
   P(X1|Class)*P(X2|Class)* .... *P(XN|Class)*P(Class).
   When you generated your Bayes Net, assume that the values 
   in the SALARY column of the dataset are the CLASS that we want to predict.
   @return a BN that is a Naive Bayes model and which represents the Adult Dataset. 
    '''
    ### READ IN THE DATA
    input_data = []
    with open('data/adult-dataset.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None) #skip header row
        for row in reader:
            input_data.append(row)

    ### DOMAIN INFORMATION REFLECTS ORDER OF COLUMNS IN THE DATA SET
    variable_domains = {
    "Work": ['Not Working', 'Government', 'Private', 'Self-emp'],
    "Education": ['<Gr12', 'HS-Graduate', 'Associate', 'Professional', 'Bachelors', 'Masters', 'Doctorate'],
    "MaritalStatus": ['Not-Married', 'Married', 'Separated', 'Widowed'],    
    "Occupation": ['Admin', 'Military', 'Manual Labour', 'Office Labour', 'Service', 'Professional'],    
    "Relationship": ['Wife', 'Own-child', 'Husband', 'Not-in-family', 'Other-relative', 'Unmarried'],
    "Race": ['White', 'Black', 'Asian-Pac-Islander', 'Amer-Indian-Eskimo', 'Other'],
    "Gender": ['Male', 'Female'],
    "Country": ['North-America', 'South-America', 'Europe', 'Asia', 'Middle-East', 'Carribean'],
    "Salary": ['<50K', '>=50K']
    }
    
    variables = []
    factors = []
    total = len(input_data)

    for var, domain in variable_domains.items():
        variables.append(Variable(var, domain))
    
    salary_index = -1
    salary_var = variables[salary_index]
    
    for i in range(len(variables)):
        if i == len(variables) - 1:
            values = []
            new_factor = Factor('P(salary)', [salary_var])
            counters = {'<50K': 0, '>=50K': 0}
            for row in input_data:
                counters[row[salary_index]] += 1
                
            for key, value in counters.items():
                prob = value / total
                values.append([key, prob])
            new_factor.add_values(values)
            factors.append(new_factor)
            
        else:
            name = "P({}|salary)".format(variables[i].name)
            new_factor = Factor(name, [variables[i], salary_var])
            cartesian = list(itertools.product(*[var.domain() for var in [variables[i], salary_var]]))
            counters = {c: 0 for c in cartesian}
            for row in input_data:
                var_value = row[i]
                salary_value = row[salary_index]
                counters[(var_value,salary_value)] += 1
            values = []
            for (domain, salary), value in counters.items():
                prob = value / total
                values.append([domain, salary, prob])
            new_factor.add_values(values)
            factors.append(new_factor)
            
    return BN('NaiveBayesModel', variables, factors)
    
def Explore(Net, question):
    '''    Input: Net---a BN object (a Bayes Net)
           question---an integer indicating the question in HW4 to be calculated. Options are:
           1. What percentage of the women in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           2. What percentage of the men in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           3. What percentage of the women in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           4. What percentage of the men in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           5. What percentage of the women in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           6. What percentage of the men in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           @return a percentage (between 0 and 100)
    ''' 
    ### YOUR CODE HERE ###
    percentage = 0.0
    
    input_data = []
    with open('data/adult-dataset.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None) #skip header row
        for row in reader:
            input_data.append(row)
    total = len(input_data)
    
    var = Net.variables()
    # indexing follows this ordering: Work,Education,MaritalStatus,Occupation,Relationship,Race,Gender,Country,Salary
    e1 = [var[0], var[3], var[1], var[4]]
    e2 = [var[0], var[3], var[1], var[4], var[6]]

    if question == 1:
        women = 0
        count = 0
        for row in input_data:
            if row[6] == 'Female':
                women += 1
                
                prob1, prob2 = find_prob(Net, e1, e2, row)
                if prob1[1] > prob2[1]:
                    
                    count += 1
        
        if count == 0:
            return percentage
                    
        return count / women
    
    elif question == 2:
        count = 0
        men = 0
        for row in input_data:
            if row[6] == 'Male':
                men += 1
                
                prob1, prob2 = find_prob(Net, e1, e2, row)
                
                if prob1[1] > prob2[1]:
                    count += 1
        if count == 0:
            return percentage
                    
        return count / men
        
    elif question == 3:
        women = 0
        count = 0
        for row in input_data:
            if row[6] == 'Female':
                women += 1
                if row[-1] == '>=50K': 
                    prob1, prob2 = find_prob(Net, e1, e2, row)
                    if prob1[1] > 0.5:
                        count += 1
        if count == 0:
            return percentage
        
        return count / women
                
    elif question == 4:
        men = 0
        count = 0
        for row in input_data:
            if row[6] == 'Male':
                men += 1
                if row[-1] == '>=50K': 
                    prob1, prob2 = find_prob(Net, e1, e2, row)
                    if prob1[1] > 0.5:
                        count += 1
        if count == 0:
            return percentage
        
        return count / men
    
    elif question == 5:
        women = 0
        count = 0
        for row in input_data:
            if row[6] == 'Female':
                women += 1
            
                prob1, prob2 = find_prob(Net, e1, e2, row)
                    
                if prob1[1] > prob2[1]:
                    count += 1
        
        if count == 0:
            return percentage
        
        return count / women
    
    else:
        men = 0
        count = 0
        for row in input_data:
            if row[6] == 'Male':
                men += 1
            
                prob1, prob2 = find_prob(Net, e1, e2, row)
                    
                if prob1[1] > prob2[1]:
                    count += 1
            
        if count == 0:
            return percentage
        
        return count / men


def find_prob(Net, e1, e2, row):
    """
    Finds probability using variable elimination for P(S=">=$50K"|E1), P(S=">=$50K"|E2)

    Returns:
        tuple of P(S=">=$50K"|E1), P(S=">=$50K"|E2)
    """
    e1[0].set_evidence(row[0])
    e1[1].set_evidence(row[3])
    e1[2].set_evidence(row[1])
    e1[3].set_evidence(row[4])
    e2[4].set_evidence(row[6])
    prob1 = VE(Net, Net.get_variable('Salary'), e1)
    prob2 = VE(Net, Net.get_variable('Salary'), e2)
    
    return prob1, prob2