import csv

from bnetbase import Variable, Factor, BN, adultDatasetBN
import itertools


def multiply_factors(Factors):
    '''return a new factor that is the product of the factors in Fators
    @return a factor'''
    name = "Mult[" + " + ".join(f.name for f in Factors) + "]"
    temp = []
    variables_product = set()
    variables_product_add = variables_product.add
    domains = {}
    for f in Factors:
        variables = f.get_scope()
        temp += variables
    variables_product = [x for x in temp if not (x in variables_product or variables_product_add(x))]

    for v in variables_product:
        domains[v] = v.domain()

    all_poss = (dict(zip(domains, x)) for x in itertools.product(
        *domains.values()))  # https://stackoverflow.com/questions/5228158/cartesian-product-of-a-dictionary-of-lists

    vals = []
    for assign in all_poss:
        val = 1
        for f in Factors:
            f_var = f.get_scope()
            f_assign = [assign[x] for x in f_var]
            val *= f.get_value(f_assign)
        vals.append([assign[x] for x in variables_product] + [val])

    f = Factor(name, variables_product)
    f.add_values(vals)
    return f


def restrict_factor(f, var, value):
    '''f is a factor, var is a Variable, and value is a value from var.domain.
    Return a new factor that is the restriction of f by this var = value.
    Don't change f! If f has only one variable its restriction yields a
    constant factor
    @return a factor'''
    var_list = f.get_scope()
    index = var_list.index(var)
    new_var_list = [v for v in var_list if v != var]
    domains = []
    name = f.name + "[Restrict:" + var.name + "]"

    for v in var_list:
        domains.append(v.domain())
    domains[index] = [value]

    all_poss = itertools.product(*domains)

    vals = []
    for assign in all_poss:
        val = f.get_value(assign)
        assign_list = list(assign)
        assign_list.pop(index)
        vals.append(assign_list + [val])

    new_factor = Factor(name, new_var_list)
    new_factor.add_values(vals)
    return new_factor


def sum_out_variable(f, var):
    '''f is a factor, var is a Variable.
    Return a new factor that is the result of summing var out of f, by summing
    the function generated by the product over all values of var.
    @return a factor'''
    var_list = f.get_scope()
    index = var_list.index(var)
    new_var_list = [v for v in var_list if v != var]
    domains = []
    name = f.name + "[Restrict:" + var.name + "]"

    for v in new_var_list:
        domains.append(v.domain())

    all_poss = itertools.product(*domains)

    vals = []
    for assign in all_poss:
        val = 0
        for v in var.domain():
            assign_list = list(assign)
            assign_list.insert(index, v)
            val += f.get_value(assign_list)
        vals.append(list(assign) + [val])

    new_factor = Factor(name, new_var_list)
    new_factor.add_values(vals)
    return new_factor


def normalize(nums):
    '''take as input a list of number and return a new list of numbers where
    now the numbers sum to 1, i.e., normalize the input numbers
    @return a normalized list of numbers'''
    sum_of_nums = sum(nums)
    if sum_of_nums == 0:
        return [1/len(nums) for _ in nums] #
    return [x/sum_of_nums for x in nums]


def min_fill_ordering(Factors, QueryVar):
    '''Compute an elimination order given a list of factors using the min fill heuristic. 
    Variables in the list will be derived from the scopes of the factors in Factors. 
    Order the list such that the first variable in the list generates the smallest
    factor upon elimination. The QueryVar must NOT part of the returned ordering using.
    @return a list of variables'''
    ### YOUR CODE HERE ###
    scopes = [list(f.get_scope()) for f in Factors]
    variables = []
    for s in scopes:
        for v in s:
            if v not in variables and v != QueryVar:
                variables.append(v)
    order = []
    while variables:
        (var, new_scope) = min_fill_var(scopes, variables)
        order.append(var)
        if var in variables:
            variables.remove(var)
        scopes = remove_variable_from_scope(var, new_scope, scopes)
    return order



def min_fill_var(scopes, variables):
    min_var = variables[0]
    (cur_min, cur_min_scope) = compute_fill(scopes, variables[0])
    for v in variables:
        (new_min, new_min_scope) = compute_fill(scopes, v)
        if new_min < cur_min:
            min_var = v
            cur_min = new_min
            cur_min_scope = new_min_scope
    return min_var, cur_min_scope

def compute_fill(scopes, variable):
    union = []
    for s in scopes:
        if variable in s:
            for v in s:
                if v not in union and v != variable:
                    union.append(v)
    return len(union), union

def remove_variable_from_scope(var, new_scope, scopes):
    scope = []
    for s in scopes:
        if var not in s:
            scope.append(s)
    scope.append(new_scope)
    return scope
###
def VE(Net, QueryVar, EvidenceVars):
    '''
    Input: Net---a BN object (a Bayes Net)
           QueryVar---a Variable object (the variable whose distribution
                      we want to compute)
           EvidenceVars---a LIST of Variable objects. Each of these
                          variables has had its evidence set to a particular
                          value from its domain using set_evidence. 

   VE returns a distribution over the values of QueryVar, i.e., a list
   of numbers one for every value in QueryVar's domain. These numbers
   sum to one, and the i'th number is the probability that QueryVar is
   equal to its i'th value given the setting of the evidence
   variables. For example if QueryVar = A with Dom[A] = ['a', 'b',
   'c'], EvidenceVars = [B, C], and we have previously called
   B.set_evidence(1) and C.set_evidence('c'), then VE would return a
   list of three numbers. E.g. [0.5, 0.24, 0.26]. These numbers would
   mean that Pr(A='a'|B=1, C='c') = 0.5 Pr(A='a'|B=1, C='c') = 0.24
   Pr(A='a'|B=1, C='c') = 0.26
    @return a list of probabilities, one for each item in the domain of the QueryVar'''
    ### YOUR CODE HERE ###
    factors = Net.factors()
    eSet = set(EvidenceVars)

    restrictFactors = []

    for f in factors:
        restrict_vars = eSet.intersection(f.get_scope())
        if restrict_vars:
            temp = f
            for rf in restrict_vars:
                temp = restrict_factor(temp, rf, rf.get_evidence())
            restrictFactors.append(temp)
        else:
            restrictFactors.append(f)

    ordering = min_fill_ordering(restrictFactors, QueryVar)

    for v in ordering:
        temp = [f for f in restrictFactors if v in f.get_scope()]
        result = sum_out_variable(multiply_factors(temp), v)
        restrictFactors = [f for f in restrictFactors if f not in temp]
        restrictFactors.append(result)

    final = multiply_factors(restrictFactors)
    distribution = [final.get_value([v]) for v in QueryVar.domain()]
    return normalize(distribution)



def NaiveBayesModel():
    '''
   NaiveBayesModel returns a BN that is a Naive Bayes model that 
   represents the joint distribution of value assignments to 
   variables in the Adult Dataset from UCI.  Remember a Naive Bayes model
   assumes P(X1, X2,.... XN, Class) can be represented as 
   P(X1|Class)*P(X2|Class)* .... *P(XN|Class)*P(Class).
   When you generated your Bayes Net, assume that the values 
   in the SALARY column of the dataset are the CLASS that we want to predict.
   @return a BN that is a Naive Bayes model and which represents the Adult Dataset. 
    '''
    ### READ IN THE DATA
    input_data = []
    with open('data/adult-dataset.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None)  # skip header row
        col_to_variableName = {str(i): headers[i] for i in range(len(headers))}
        for row in reader:
            input_data.append(row)

    ### DOMAIN INFORMATION REFLECTS ORDER OF COLUMNS IN THE DATA SET
    variable_domains = {
        "MaritalStatus": ['Not-Married', 'Married', 'Separated', 'Widowed'],
        "Relationship": ['Wife', 'Own-child', 'Husband', 'Not-in-family', 'Other-relative', 'Unmarried'],
        "Race": ['White', 'Black', 'Asian-Pac-Islander', 'Amer-Indian-Eskimo', 'Other'],
        "Gender": ['Male', 'Female'],
        "Occupation": ['Admin', 'Military', 'Manual Labour', 'Office Labour', 'Service', 'Professional'],
        "Country": ['North-America', 'South-America', 'Europe', 'Asia', 'Middle-East', 'Carribean'],
        "Education": ['<Gr12', 'HS-Graduate', 'Associate', 'Professional', 'Bachelors', 'Masters', 'Doctorate'],
        "Work": ['Not Working', 'Government', 'Private', 'Self-emp'],
        "Salary": ['<50K', '>=50K']
    }
    ### YOUR CODE HERE ###
    variables = []
    factors = []
    value = {}
    name_to_factor = {}

    salary_variable = None
    for variable in variable_domains:
        new_var = Variable(variable, variable_domains[variable])
        variables.append(new_var)
        if variable == 'Salary':
            salary_variable = new_var

    for variable in variables:
        if variable.name != 'Salary':
            new_factor = Factor("P({}|Salary)".format(variable.name), [variable, salary_variable])
            value[(variable.name, 'Salary')] = {}
            name_to_factor[(variable.name, 'Salary')] = new_factor
        else:
            new_factor = Factor("P(Salary)", [salary_variable])
            value['Salary'] = {}
            name_to_factor['Salary'] = new_factor
        factors.append(new_factor)

    for row in input_data:
        salary = row[-1]
        for i in range(len(row)-1):
            variable_name = col_to_variableName[str(i)]
            value[(variable_name, 'Salary')].setdefault((row[i], salary), 0)
            value[(variable_name, 'Salary')][(row[i], salary)] += 1
        value['Salary'].setdefault((salary,), 0)
        value['Salary'][(salary,)] += 1

    #calculate distribution
    for factor_name in value:
        less_than = 0
        more_than = 0
        for key in list(value[factor_name].keys()):
            if "<50K" in key:
                less_than += value[factor_name][key]
            else:
                more_than += value[factor_name][key]
        f_value = []
        for key in value[factor_name]:
            if "<50K" in key:
                value[factor_name][key] = value[factor_name][key] / less_than
            else:
                value[factor_name][key] = value[factor_name][key] / more_than
            f_value.append(list(key) + [value[factor_name][key]])
        f = name_to_factor[factor_name]
        f.add_values(f_value)

    nativeBN = BN("Native Adult Dataset", variables, factors)
    return nativeBN


def Explore(Net, question):
    '''    Input: Net---a BN object (a Bayes Net)
           question---an integer indicating the question in HW4 to be calculated. Options are:
           1. What percentage of the women in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           2. What percentage of the men in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)?
           3. What percentage of the women in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           4. What percentage of the men in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K?
           5. What percentage of the women in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           6. What percentage of the men in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall?
           @return a percentage (between 0 and 100)
    '''
    input_data = []
    with open('data/test-data.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        headers = next(reader, None)  # skip header row
        for row in reader:
            input_data.append(row)

    variables = {}
    for v in Net.variables():
        variables[v.name] = v

    e1 = [variables['Work'], variables['Occupation'], variables['Education'], variables['Relationship']]
    e2 = [variables['Work'], variables['Occupation'], variables['Education'], variables['Relationship'], variables['Gender']]
    #set evidence
    if question == 1:
        num_woman = 0
        suc = 0
        for input in input_data:
            if input[6] == 'Female':
                num_woman += 1
                set_eSet(e1, e2, input)
                a = VE(Net, variables['Salary'], e1)[1]
                b = VE(Net, variables['Salary'], e2)[1]
                if a > b:
                    suc += 1
        return suc / num_woman
    elif question == 2:
        num_man = 0
        suc = 0
        for input in input_data:
            if input[6] == 'Male':
                num_man += 1
                set_eSet(e1, e2, input)
                a = VE(Net, variables['Salary'], e1)[1]
                b = VE(Net, variables['Salary'], e2)[1]
                if a > b:
                    suc += 1
        return suc / num_man
    elif question == 3:
        num_prediction = 0
        suc = 0
        for input in input_data:
            if input[6] == 'Female':
                set_eSet(e1, e2, input)
                a = VE(Net, variables['Salary'], e1)[1]
                if a > 0.5:
                    num_prediction += 1
                    if input[-1] == '>=50K':
                        suc += 1
        return suc / num_prediction
    elif question == 4:
        num_prediction = 0
        suc = 0
        for input in input_data:
            if input[6] == 'Male':
                set_eSet(e1, e2, input)
                a = VE(Net, variables['Salary'], e1)[1]
                if a > 0.5:
                    num_prediction += 1
                    if input[-1] == '>=50K':
                        suc += 1
        return suc / num_prediction
    elif question == 5:
        num_woman = 0
        succ = 0
        for input in input_data:
            if input[6] == 'Female':
                num_woman += 1
                set_eSet(e1, e2, input)
                a = VE(Net, variables['Salary'], e1)[1]
                if a > 0.5:
                    succ += 1
        return succ/num_woman
    elif question == 6:
        num_woman = 0
        succ = 0
        for input in input_data:
            if input[6] == 'Male':
                num_woman += 1
                set_eSet(e1, e2, input)
                a = VE(Net, variables['Salary'], e1)[1]
                if a > 0.5:
                    succ += 1
        return succ/num_woman

def set_eSet(e1, e2, row):
    e1[0].set_evidence(row[0])
    e1[1].set_evidence(row[3])
    e1[2].set_evidence(row[1])
    e1[3].set_evidence(row[4])
    e2[-1].set_evidence(row[6])


if __name__=='__main__':
    net = NaiveBayesModel()
    print('Question 1: ', Explore(net, 1))
    print('Question 2: ', Explore(net, 2))
    print('Question 3: ', Explore(net, 3))
    print('Question 4: ', Explore(net, 4))
    print('Question 5: ', Explore(net, 5))
    print('Question 6: ', Explore(net, 6))