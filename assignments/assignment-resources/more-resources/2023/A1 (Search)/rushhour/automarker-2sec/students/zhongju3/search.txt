Some of the most significant things I have learned from this exercise are: writing my own heuristics to estimate the additional steps from one state to the goal state with regard to the role that a heuristic plays in a search algorithm; actually implementing the search algorithms we have learned in class and variations of them; understanding how these search algorithms build the bases of artificial intelligence.
    Writing the heur_min_dist was straightforward, as I just had to compute the distance of each car to the goal without considering the orientation of the goal and return the smallest number of steps. The tricky part was realizing a car could initially be wrapped around the board and the part of the car that is on the other side of the board is touching the goal. I did not think of this edge case at first causing me to fail some test cases.
    heur_alternate had me thinking of various ways to implement it. I initially wanted to do the sum of 1. what  heur_min_dist(state) computes for one car, 2. and the number of obstacles between the current car and the goal, 3. in addition to the number of other obstacles that block the obstacle. This idea came out to be difficult to implement as in the last part, I thought it was very easy to overestimate the cost and lead to a bad heuristic. Therefore in the actual implementation and left out part 3 to ensure a heuristic that can fairly well estimate the potential number of moves and never over-estimates.